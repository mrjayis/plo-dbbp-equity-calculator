
<!DOCTYPE html>

<html lang="en">
<head>
<style>
@import url('https://fonts.googleapis.com/css2?family=Syne:wght@600;700;800&family=JetBrains+Mono:ital,wght@0,400;0,600;0,700;1,400&family=DM+Sans:wght@400;500;600&display=swap');

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PLO DBBP Equity Calculator â€” Design System v2
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Design Tokens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
:root {
  --bg:          #060a0f;
  --surface-0:   #09101a;
  --surface-1:   #0d1827;
  --surface-2:   #112034;
  --surface-3:   #1a2d44;

  --accent:      #00e87a;
  --accent-dim:  rgba(0,232,122,.15);
  --accent-2:    #00c4f5;
  --accent-2-dim:rgba(0,196,245,.1);

  --text:        #dde8f5;
  --muted:       #6b8aaa;
  --subtle:      #374f67;

  --err:         #ff5a72;
  --ok:          #00e87a;

  --border:      #1b2e47;
  --border-hi:   #263f5c;

  --r-sm:  8px;
  --r-md:  12px;
  --r-lg:  16px;
  --r-xl:  20px;

  --elev-0: 0 2px 8px rgba(0,0,0,.35);
  --elev-1: 0 6px 24px rgba(0,0,0,.45);
  --elev-2: 0 12px 40px rgba(0,0,0,.6);

  --font-display: 'Syne', ui-sans-serif, system-ui;
  --font-body:    'DM Sans', ui-sans-serif, system-ui, -apple-system;
  --font-mono:    'JetBrains Mono', ui-monospace, monospace;

  /* Legacy aliases */
  --panel:       var(--surface-1);
  --board-scale: 1.05;
  --radius:      var(--r-md);
  --radius-lg:   var(--r-lg);
}

/* â”€â”€ Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; }

html { -webkit-text-size-adjust: 100%; max-width: 100vw; overflow-x: hidden; }

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-body);
  min-height: 100dvh;
  max-width: 100vw;
  overflow-x: hidden;
  background-image:
    radial-gradient(ellipse 80% 50% at 50% -5%, rgba(0,100,255,.07), transparent),
    radial-gradient(ellipse 60% 40% at 80% 110%, rgba(0,232,122,.04), transparent);
}

/* â”€â”€ Typography â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
h1 {
  font-family: var(--font-display);
  font-size: clamp(20px, 4vw, 30px);
  font-weight: 800;
  letter-spacing: -0.5px;
  text-align: center;
  padding: 28px 16px 20px;
  background: linear-gradient(90deg, var(--accent), var(--accent-2) 55%, var(--text));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.wrap {
  max-width: 1440px;
  width: 100%;
  margin: 0 auto 32px;
  padding: 0 16px;
}

.wrap.grid {
  display: grid;
  grid-template-columns: 57fr 43fr;
  gap: 20px;
  align-items: start;
}

@media (max-width: 960px) {
  .wrap.grid { grid-template-columns: 1fr; }
}

/* â”€â”€ Panels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel {
  background: var(--surface-1);
  border: 1px solid var(--border);
  border-radius: var(--r-xl);
  box-shadow: var(--elev-1);
  padding: 16px;
  max-width: 100%;
  overflow-x: hidden;
}

.panel.results {
  display: flex;
  flex-direction: column;
  min-height: 300px;
  overflow-y: auto;
  overflow-x: hidden;
  box-shadow: var(--elev-2);
  position: sticky;
  top: 16px;
  min-width: 0;
}

@media (max-width: 960px) {
  .panel.results { position: static; }
}

/* â”€â”€ Header bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.headerbar {
  position: sticky;
  top: 0;
  z-index: 50;
  backdrop-filter: saturate(150%) blur(12px);
  -webkit-backdrop-filter: saturate(150%) blur(12px);
  background: linear-gradient(180deg, rgba(6,10,15,.92), rgba(6,10,15,.76));
  border-bottom: 1px solid var(--border);
  padding: 10px 20px;
  display: flex;
  align-items: center;
  gap: 12px;
}
.headerbar h1 { margin: 0; padding: 0; font-size: 20px; }
.headerbar .right { margin-left: auto; display: flex; gap: 8px; align-items: center; }

/* â”€â”€ Seat Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.controls-seats {
  display: grid;
  grid-template-columns: repeat(12, 1fr);
  gap: 10px;
}

.seat {
  grid-column: span 12;
  background: linear-gradient(145deg, var(--surface-2), var(--surface-1));
  border: 1px solid var(--border);
  border-radius: var(--r-lg);
  padding: 12px 14px;
  max-height: 220px;
  overflow: hidden;
  box-shadow: var(--elev-0), inset 0 1px 0 rgba(255,255,255,.04);
  transition:
    max-height .22s ease, margin .22s ease,
    padding .22s ease, opacity .18s ease,
    transform .18s ease, box-shadow .2s ease,
    border-color .2s ease;
}

.seat:focus-within {
  border-color: var(--border-hi);
  box-shadow: var(--elev-0), 0 0 0 1px rgba(0,232,122,.15), inset 0 1px 0 rgba(255,255,255,.06);
}

@media (min-width: 720px)  { .seat { grid-column: span 6; } }
@media (min-width: 1024px) { .seat { grid-column: span 4; } }
@media (min-width: 1200px) { .controls-seats { gap: 12px; } .seat { padding: 14px; } }

.seat.collapsed {
  max-height: 0;
  margin-top: 0; margin-bottom: 0;
  padding-top: 0; padding-bottom: 0;
  opacity: 0;
  transform: translateY(-4px);
  pointer-events: none;
  border-color: transparent;
}

.seat.disabled { opacity: .38; filter: grayscale(.3); }
.seat.disabled input { pointer-events: none; }

.seat h4 {
  margin: 0 0 8px;
  font-family: var(--font-body);
  font-size: 11px;
  font-weight: 600;
  letter-spacing: .8px;
  text-transform: uppercase;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.seat input {
  width: 100%;
  padding: 9px 12px;
  border-radius: var(--r-sm);
  border: 1px solid var(--border);
  background: var(--surface-0);
  color: var(--text);
  font-family: var(--font-mono);
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 1px;
  transition: border-color .15s, box-shadow .15s;
  margin-bottom: 6px;
}

.seat input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(0,232,122,.18);
}

.seat input.dup {
  border-color: var(--err);
  box-shadow: 0 0 0 2px rgba(255,90,114,.2);
}

/* â”€â”€ Card chips under inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.seat .chipout, .cardin .chipout {
  margin-top: 4px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  align-items: center;
  min-height: 28px;
}

@media (max-width: 600px) { .seat .chipout { min-height: 44px; } }

.seat .chipout .cardchip, .cardin .chipout .cardchip {
  font-size: 16px;
  transform: translateY(-1px);
}

/* Board chips center-aligned */
.cardin { position: relative; }
.cardin .chipout {
  justify-content: center;
  width: 100%;
  margin-left: 0;
  margin-right: 0;
}

/* â”€â”€ Board Inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.board {
  background: var(--surface-1);
  border: 1px solid var(--border);
  border-radius: var(--r-lg);
  padding: 12px 14px;
  margin: 8px 0;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
}

.board h3 {
  margin: 0 0 12px;
  font-family: var(--font-display);
  font-size: 14px;
  font-weight: 700;
  letter-spacing: .4px;
  text-transform: uppercase;
  color: var(--muted);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
}

.board .controls { display: flex; gap: 6px; flex-wrap: wrap; }

.cards {
  display: flex;
  gap: 8px;
  justify-content: center;
  flex-wrap: wrap;
}

/* Card slot â€” card-like proportions */
.cardin { width: 72px; }

.cardin input {
  width: 100%;
  aspect-ratio: 5 / 7;
  text-transform: uppercase;
  padding: 0;
  border-radius: var(--r-md);
  border: 1px solid var(--border);
  background: linear-gradient(160deg, var(--surface-2), var(--surface-0));
  color: var(--text);
  text-align: center;
  font-family: var(--font-mono);
  font-weight: 800;
  letter-spacing: 1.5px;
  font-size: 16px;
  box-shadow: var(--elev-0), inset 0 1px 0 rgba(255,255,255,.05), inset 0 -2px 0 rgba(0,0,0,.3);
  transition: border-color .15s, box-shadow .15s, background .15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cardin input:focus {
  outline: none;
  border-color: var(--accent);
  background: linear-gradient(160deg, var(--surface-3), var(--surface-1));
  box-shadow: 0 0 0 2px rgba(0,232,122,.22), var(--elev-0);
}

.cardin input.dup {
  border-color: var(--err);
  box-shadow: 0 0 0 2px rgba(255,90,114,.2);
}

/* â”€â”€ Card Chips â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.cardchip {
  display: inline-flex;
  align-items: center;
  gap: 3px;
  padding: 3px 7px;
  margin: 0 1px;
  border-radius: var(--r-sm);
  border: 1px solid var(--border-hi);
  background: var(--surface-2);
  font-family: var(--font-mono);
  font-weight: 800;
  letter-spacing: .3px;
  font-size: 20px;
  box-shadow: 0 1px 3px rgba(0,0,0,.3);
}

.cardchip.cardchip-wild { border-style: dashed; opacity: .85; }
.cardchip-not { font-weight: 700; letter-spacing: .2px; opacity: .85; }

.sym-x { font-size: .9em; line-height: 1; vertical-align: middle; }
.sym    { font-size: 16px; opacity: .95; }
.s-spade   { color: #dde8f5; }
.s-heart   { color: #ff6b6b; }
.s-diamond { color: #60a5fa; }
.s-club    { color: #34d399; }

/* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn {
  cursor: pointer;
  border: 1px solid var(--border-hi);
  background: var(--surface-2);
  color: var(--muted);
  border-radius: var(--r-sm);
  padding: 7px 13px;
  font-family: var(--font-body);
  font-size: 13px;
  font-weight: 600;
  letter-spacing: .1px;
  transition: color .15s, background .15s, border-color .15s, transform .08s, box-shadow .2s;
  box-shadow: 0 1px 0 rgba(255,255,255,.04) inset;
}

.btn:hover:not(:disabled) {
  color: var(--text);
  background: var(--surface-3);
  border-color: var(--border-hi);
  transform: translateY(-1px);
  box-shadow: var(--elev-0);
}

.btn:active:not(:disabled) { transform: translateY(0); }
.btn:disabled { opacity: .38; cursor: default; }

.btn.primary {
  background: linear-gradient(135deg, #00c96a, #00e87a);
  border-color: rgba(0,232,122,.45);
  color: #031a0e;
  font-weight: 700;
  box-shadow: 0 4px 20px rgba(0,232,122,.38), 0 1px 0 rgba(255,255,255,.14) inset;
}

.btn.primary:hover:not(:disabled) {
  background: linear-gradient(135deg, #00df74, #00ffaa 130%);
  box-shadow: 0 6px 28px rgba(0,232,122,.55), 0 1px 0 rgba(255,255,255,.18) inset;
  transform: translateY(-1px);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border);
  color: var(--muted);
  box-shadow: none;
}

.btn.ghost:hover:not(:disabled) {
  background: rgba(255,255,255,.04);
  border-color: var(--border-hi);
  color: var(--text);
}

/* â”€â”€ Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.toggle {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 7px 12px;
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  background: var(--surface-2);
  color: var(--text);
  cursor: pointer;
  font-size: 13px;
  transition: border-color .15s;
}
.toggle:hover { border-color: var(--border-hi); }
.toggle input { accent-color: var(--accent); width: 16px; height: 16px; }

/* â”€â”€ Controls rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.controls-extended {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
  margin-top: 8px;
}

/* â”€â”€ Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.badge {
  display: inline-block;
  padding: 2px 9px;
  border: 1px solid var(--border-hi);
  border-radius: 999px;
  font-size: 11px;
  font-weight: 600;
  color: var(--muted);
  background: var(--surface-2);
}

/* â”€â”€ Form selects / text inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
select, input[type="text"] {
  background: var(--surface-0);
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  color: var(--text);
  padding: 6px 10px;
  font-family: var(--font-body);
  font-size: 13px;
  transition: border-color .15s;
}
select:focus, input[type="text"]:focus { outline: none; border-color: var(--accent); }
#scenarioName { width: 180px; }

/* â”€â”€ Progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.progress {
  height: 6px;
  background: var(--surface-3);
  border: 1px solid var(--border);
  border-radius: 999px;
  overflow: hidden;
  margin: 12px 0 4px;
}

.bar {
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--accent), var(--accent-2));
  border-radius: 999px;
  transition: width .1s ease;
  box-shadow: 0 0 8px rgba(0,232,122,.45);
}

.progress-row {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: space-between;
}

#progressLabel {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--muted);
  min-width: 0;
}

/* â”€â”€ Error box â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.errbox {
  display: none;
  margin-top: 10px;
  border: 1px solid rgba(255,90,114,.3);
  background: rgba(255,90,114,.07);
  color: #ffb3c0;
  border-radius: var(--r-md);
  padding: 10px 14px;
  font-size: 13px;
}
.errbox.show { display: block; }

/* â”€â”€ Results panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel.results h2 {
  font-family: var(--font-display);
  font-size: 14px;
  font-weight: 700;
  color: var(--muted);
  margin: 0 0 12px 8px;
  letter-spacing: .8px;
  text-transform: uppercase;
}

.boards-out {
  display: block;
  max-width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  padding-bottom: 8px;
}

.boards-inner {
  display: flex;
  flex-direction: column;
  gap: 6px;
  max-width: 100%;
  flex-wrap: nowrap;
}

.boards-inner strong { opacity: .8; font-size: 12px; }

#resultsFilters {
  position: sticky;
  top: 40px;
  z-index: 40;
  padding: 6px 8px;
  background: linear-gradient(180deg, rgba(13,24,39,.96), rgba(13,24,39,.72));
  border-radius: var(--r-md);
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin: 0 0 8px;
}

/* â”€â”€ Results Table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tablewrap {
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  border-radius: var(--r-md);
}

#resultsTable {
  width: 100%;
  min-width: 100%;
  border-collapse: separate;
  border-spacing: 0 4px;
  font-variant-numeric: tabular-nums;
  font-family: var(--font-mono);
  font-size: 13px;
  table-layout: auto;
}

#resultsTable thead th {
  position: sticky;
  top: 0;
  background: var(--surface-1);
  box-shadow: 0 2px 0 var(--border);
  font-family: var(--font-body);
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: .8px;
  color: var(--muted);
  padding: 8px 10px;
  text-align: center;
  white-space: nowrap;
}

#resultsTable tbody tr {
  background: var(--surface-1);
  transition: filter .12s;
}
#resultsTable tbody tr:hover { filter: brightness(1.1); }

#resultsTable td {
  padding: 9px 10px;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  overflow: visible;
  white-space: nowrap;
  vertical-align: middle;
  text-align: center;
}

#resultsTable tbody tr td:first-child {
  border-left: 1px solid var(--border);
  border-top-left-radius: var(--r-sm);
  border-bottom-left-radius: var(--r-sm);
  opacity: .7;
  font-size: 11px;
}

#resultsTable tbody tr td:last-child {
  border-right: 1px solid var(--border);
  border-top-right-radius: var(--r-sm);
  border-bottom-right-radius: var(--r-sm);
}

#resultsTable th:nth-child(2),
#resultsTable td:nth-child(2) { text-align: left; white-space: normal; }

#resultsTable td:nth-child(6),
#resultsTable td:nth-child(7) {
  color: var(--muted);
  font-family: var(--font-body);
  font-size: 12px;
  line-height: 1.2;
}

.good {
  color: var(--accent);
  font-weight: 700;
  padding: 2px 8px;
  border-radius: 6px;
  background: rgba(0,232,122,.1);
}

/* Equity bucket row tints */
tr.bucket-top      { background: rgba(0,232,122,.09)  !important; }
tr.bucket-strong   { background: rgba(234,179,8,.08)   !important; }
tr.bucket-medium   { background: rgba(56,189,248,.07)  !important; }
tr.bucket-marginal { background: rgba(100,116,139,.06) !important; }
tr.bucket-weak     { background: rgba(255,90,114,.08)  !important; }

#winHandsSummary {
  font-size: 12px;
  color: var(--muted);
  margin: 6px 0 12px;
  font-family: var(--font-body);
  line-height: 1.6;
}

/* â”€â”€ Range / Bucket UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.bucketGroup {
  display: inline-flex;
  gap: 2px;
  padding: 2px 4px;
  border-radius: 999px;
  background: var(--surface-0);
  border: 1px solid var(--border-hi);
}
.bucketGroup input[type="checkbox"] { display: none; }

.bucketBtn {
  border: none;
  border-radius: 999px;
  padding: 2px 6px;
  font-size: 10px;
  line-height: 1;
  cursor: pointer;
  background: transparent;
  color: var(--muted);
  opacity: .7;
}
.bucketBtn.active {
  background: var(--accent);
  color: #020f07;
  opacity: 1;
  font-weight: 700;
}

.bucketToggle { font-size: 10px; line-height: 1; padding: 2px 5px; border-radius: 999px; cursor: pointer; opacity: .65; }
.bucketToggle input:checked + span, .bucketToggle input:checked { opacity: 1; font-weight: 700; }
.bucketSelect { font-size: 11px; padding: 3px 6px; min-width: auto; }

.range-label {
  display: block;
  margin-top: 4px;
  font-size: 20px;
  font-weight: 700;
  color: #d0e0ff;
  line-height: 1.2;
  text-align: left;
  opacity: .8;
  letter-spacing: .4px;
}

body.range-mode-on .seat.range-bucket {
  box-shadow: 0 0 0 1px var(--accent), var(--elev-0);
}
body.range-mode-on .seat.range-bucket h4 span:first-child::after {
  content: ' â€¢ RANGE';
  color: var(--accent);
  font-size: 11px;
  margin-left: 4px;
}

/* â”€â”€ Bucket legend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#bucketLegend {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 8px;
  margin-top: 8px;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  background: var(--surface-1);
  font-size: 12px;
}
.legend-swatch { width: 20px; height: 20px; border-radius: 4px; border: 1px solid var(--border); }

/* â”€â”€ Quiz / masked cells â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.hidden-answer { filter: blur(4px); }
td.masked { opacity: .85; }

/* â”€â”€ Self-test output â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#selfTest { margin-top: 8px; color: var(--muted); font-size: 12px; font-family: var(--font-mono); }

/* â”€â”€ IAP lock: blur premium-only columns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
body.iap-locked #resultsTable td:nth-child(4),
body.iap-locked #resultsTable td:nth-child(5),
body.iap-locked #resultsTable td:nth-child(7),
body.iap-locked #resultsTable td:nth-child(8),
body.iap-locked #resultsTable td:nth-child(9) {
  position: relative;
  filter: blur(5px);
  pointer-events: none;
}

body.iap-locked #resultsTable td:nth-child(4)::after,
body.iap-locked #resultsTable td:nth-child(5)::after,
body.iap-locked #resultsTable td:nth-child(7)::after,
body.iap-locked #resultsTable td:nth-child(8)::after,
body.iap-locked #resultsTable td:nth-child(9)::after {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, transparent 0%, rgba(6,10,15,.75) 70%);
}

body.iap-locked #resultsTable thead tr { position: relative; }
body.iap-locked #resultsTable thead tr::after {
  content: "";
  position: absolute;
  right: 12px;
  top: -4px;
  font-size: 11px;
  color: #ffd27f;
  opacity: .9;
}

body.iap-locked .likely-b-summary,
body.iap-locked .likely-b-summary * { filter: blur(6px); pointer-events: none; }

/* IAP upgrade banner */
#iap-upgrade-container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 8px 10px;
  margin: 4px 0 8px;
  border-radius: var(--r-sm);
  background: linear-gradient(90deg, var(--surface-2), var(--surface-1));
  border: 1px solid var(--border-hi);
  color: var(--text);
  font-size: 11px;
}
body:not(.iap-locked) #iap-upgrade-container { display: none; }

.iap-banner-text { display: flex; flex-direction: column; gap: 2px; min-width: 0; }
.iap-banner-title { font-size: 11px; font-weight: 600; color: var(--text); }
.iap-banner-subtitle { font-size: 10px; color: var(--muted); line-height: 1.3; }
.iap-banner-actions { display: flex; flex-wrap: nowrap; align-items: center; gap: 6px; }

.iap-btn {
  border: none;
  border-radius: 999px;
  padding: 5px 10px;
  font-size: 10px;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  transition: background-color .15s, color .15s, box-shadow .15s, transform .05s;
}
.iap-btn-primary {
  background: radial-gradient(circle at 0% 0%, #38bdf8, #0ea5e9);
  color: #0b1120;
  box-shadow: 0 1px 4px rgba(56,189,248,.6);
}
.iap-btn-primary:hover { background: radial-gradient(circle at 0% 0%, #0ea5e9, #0284c7); box-shadow: 0 2px 6px rgba(56,189,248,.8); transform: translateY(-.5px); }
.iap-btn-primary:active { transform: translateY(0); }
.iap-btn-ghost { background: transparent; color: var(--text); border: 1px solid var(--border-hi); }
.iap-btn-ghost:hover { background: rgba(255,255,255,.05); border-color: var(--border); }

@media (max-width: 540px) {
  #iap-upgrade-container { flex-direction: column; align-items: stretch; gap: 6px; }
  .iap-banner-actions { justify-content: flex-end; }
  .iap-btn { padding-inline: 12px; }
}

/* â”€â”€ Single-board mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
body.single-board-mode #resultsTable th:nth-child(3),
body.single-board-mode #resultsTable td:nth-child(3),
body.single-board-mode #resultsTable th:nth-child(4),
body.single-board-mode #resultsTable td:nth-child(4),
body.single-board-mode #resultsTable th:nth-child(7),
body.single-board-mode #resultsTable td:nth-child(7),
body.single-board-mode #resultsTable th:nth-child(8),
body.single-board-mode #resultsTable td:nth-child(8),
body.single-board-mode #resultsTable th:nth-child(9),
body.single-board-mode #resultsTable td:nth-child(9) { display: none; }

body:not(.single-board-mode) #resultsTable th.col-chop,
body:not(.single-board-mode) #resultsTable td.col-chop { display: none; }

#resultsTable td.col-chop,
#resultsTable th.col-chop { text-align: center !important; white-space: nowrap; min-width: 52px; }

/* â”€â”€ Help modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#helpContent h3 { font-size: 22px; font-weight: 700; letter-spacing: .2px; }
#helpContent h4 { font-size: 18px; font-weight: 650; margin-top: 10px; }
#helpContent h5 { font-size: 16px; font-weight: 600; opacity: .95; }

@media (max-width: 600px) {
  #helpContent h3 { font-size: 20px; }
  #helpContent h4 { font-size: 17px; }
  #helpContent h5 { font-size: 15px; }
}

/* â”€â”€ iOS Safari: prevent zoom on focus â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@supports (-webkit-touch-callout: none) {
  input[type="text"], input[type="number"], input[type="file"], select, textarea {
    font-size: 16px !important;
  }
}

/* â”€â”€ Safe area â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@supports (padding: max(0px)) {
  body {
    padding-block-start: max(24px, env(safe-area-inset-top));
    padding-block-end:   max(16px, env(safe-area-inset-bottom));
    padding-inline:      max(8px,  env(safe-area-inset-left));
  }
  .headerbar {
    padding-left:  max(16px, env(safe-area-inset-left));
    padding-right: max(16px, env(safe-area-inset-right));
  }
}

/* â”€â”€ Responsive â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@media (max-width: 768px) {
  h1 { font-size: clamp(18px, 5.2vw, 24px); padding: 16px; }
  .wrap { padding: 0 10px; }
  .panel { border-radius: var(--r-lg); }
  .panel.results { min-height: 220px; }
  .controls-seats { grid-template-columns: repeat(6, 1fr); gap: 8px; }
  .seat { grid-column: span 6; padding: 10px; }
  .seat h4 { font-size: 11px; }
  .seat input { font-size: 13px; padding: 8px 10px; }
  .cards { gap: 6px; }
  .cardin { width: clamp(56px, 14vw, 70px); }
  .cardin input { font-size: clamp(13px, 3.8vw, 15px); border-radius: var(--r-sm); }
  .cardchip { font-size: clamp(14px, 3.8vw, 18px); padding: 3px 6px; }
  .sym { font-size: clamp(11px, 3.2vw, 15px); }
  .btn { padding: 7px 10px; font-size: 12px; }
  .board h3 { font-size: clamp(13px, 3.8vw, 16px); }
  #resultsTable th, #resultsTable td { padding: 6px 8px; font-size: 13px; }
  #resultsFilters { top: 46px; }
  #bucketLegend { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
  .range-label { font-size: 18px; }
}

@media (max-width: 560px) {
  .controls-seats { grid-template-columns: repeat(4, 1fr); }
  .seat { grid-column: span 4; }
  .cardin { width: clamp(52px, 16vw, 66px); }
}

@media (max-width: 420px) {
  .controls-seats { grid-template-columns: repeat(2, 1fr); }
  .seat { grid-column: span 2; }
  .cardchip { font-size: clamp(12px, 3.4vw, 16px); }
  .sym { font-size: clamp(10px, 3vw, 13px); }
  .board { padding: 8px; margin: 4px 0; }
  .cards { gap: 5px; }
  #trials { width: 76px !important; padding: 6px 8px !important; }
  #resultsTable th, #resultsTable td { font-size: 13px; }
  .range-label { font-size: 17px; }
}

@media (max-width: 420px) and (orientation: portrait) {
  h1 { margin-top: 8px; margin-bottom: 6px; }
  .controls-extended { gap: 6px; }
  .btn { padding: 6px 9px; }
}

@media (max-height: 480px) and (orientation: landscape) {
  h1 { padding: 10px 12px; }
  .seat { padding: 8px; }
  .board { padding: 6px; }
  .btn { padding: 6px 8px; }
  .cardin { width: clamp(46px, 9vw, 64px); }
  .cardin input { padding: 4px; }
  .cardchip { font-size: clamp(12px, 2.4vw, 16px); padding: 2px 5px; }
  #resultsTable th, #resultsTable td { padding: 4px 6px; }
  #resultsFilters { top: 38px; }
}

</style>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport"/>
<title>PLO DBBP Equity Calculator</title>





</head>

<body >
    
      <h1 style="
  margin:0;
  font-size:32px;
  font-weight:700;
  letter-spacing:0.25px;
  text-align:center;
  background:linear-gradient(90deg,#7bd389,#2dd6a7,#38bdf8);
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
">
  âš”ï¸ PLO DBBP Equity âš”ï¸
</h1>
    </div>

<div class="wrap grid">
<!-- Left column: Seats + Boards -->
<div class="panel">
<div class="controls-extended" id="cardModeControls" style="margin:8px;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
<label class="toggle"><input checked="" id="cardMode4" name="cardmode" type="radio" value="4"/><span>PLO</span></label>
<label class="toggle"><input id="cardMode5" name="cardmode" type="radio" value="5"/><span>PLO5</span></label>
<label class="toggle"><input id="cardMode6" name="cardmode" type="radio" value="6"/><span>PLO6</span></label>
<span class="badge" id="cardModeStatus">Currently: PLO (4-card)</span>
<label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#9fb3c8;">
  Players
  <select id="numPlayersSelect" style="background:#0b111b;border:1px solid var(--border);border-radius:8px;color:#ffffff;padding:4px 8px;font-size:12px;">
    <!-- Options populated dynamically -->
  </select>
</label>
<button class="btn ghost" type="button"
        onclick="document.getElementById('helpModal').style.display='block'">
  â“ Help
</button>
<!-- Buckets link temporarily disabled
<button class="btn ghost" type="button"
        onclick="document.getElementById('bucketsModal').style.display='block'">
  ğŸ§® Buckets
</button>
-->

</div>
<div class="controls-seats" id="seats"></div>
<div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-top:8px;flex-wrap:wrap">
<div>
<button class="btn" id="randEmptySeats">ğŸ² Random empty seats</button>
<button class="btn" id="randAllSeats">ğŸ² Randomize all seats</button>
</div>
<div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
<label style="display:flex;align-items:center;gap:6px;font-size:11px;color:#9fb3c8;">
  Mode
  <select id="viewModeSelect" style="background:#020617;border:1px solid var(--border);border-radius:8px;color:#ffffff;padding:4px 8px;font-size:11px;">
    <option value="random">V Random (Non-Omniscient)</option>
    <option value="exact" selected>V Exact (Omniscient)</option>
  </select>
</label>
<!-- Range mode (buckets) temporarily disabled
<label class="toggle" title="When on: seats with a bucket selected are treated as hand ranges (reâ€‘randomized each trial) instead of fixed hands.">
  <input type="checkbox" id="rangeModeToggle">
  <span>Range mode (buckets)</span>
</label>
-->
<label style="margin-left:4px;color:#9fb3c8">Trials <input id="trials" min="100" step="100" style="width:90px;background:#0b111b;border:1px solid var(--border);border-radius:8px;color:#ffffff;padding:6px 8px" type="number" value="10000"/></label>
<button class="btn" id="resetBtn">Reset</button>
<button class="btn primary" id="runBtn">Run Monte Carlo</button>
<button class="btn ghost" disabled="" id="cancelBtn">Cancel</button>

<div class="controls-extended" id="scenarioControls">
<input id="scenarioName" placeholder="Scenario name" type="text" autocomplete="off"/>
<button class="btn" id="saveScenario" title="Save seats/boards/settings">ğŸ’¾ Save</button>
<select id="scenarioList" title="Load saved scenario">
<option value="">Loadâ€¦</option>
</select>
<button class="btn" disabled="" id="deleteScenario" title="Delete selected">ğŸ—‘ï¸ Delete</button>

<!--<label class="btn ghost" for="importFile" title="Import JSON">â¬†ï¸ Import</label> -->

</div>
</div>
<div class="controls-extended" id="templateControls"> <select id="templateList" title="Preloaded 8-way scenarios"> <option value="">Templatesâ€¦</option> </select> <button class="btn" id="loadTemplate">Load Template</button></div>
</div>
<!-- Boards -->
<div class="board" id="boardA">
<h3>
<span>Board A</span>
<span class="controls">
<button class="btn" id="randA">ğŸ² Fill empties</button>
<button class="btn" id="randAFlop">ğŸ² Flop</button>
<button class="btn" id="randATurn">ğŸ² Turn</button>
<button class="btn" id="randARiver">ğŸ² River</button>
<button class="btn" id="clearA">âœ–ï¸ Clear</button>
</span>
</h3>
<div class="cards">
<div class="cardin"><input data-slot="A0" maxlength="2" placeholder="F1"/></div>
<div class="cardin"><input data-slot="A1" maxlength="2" placeholder="F2"/></div>
<div class="cardin"><input data-slot="A2" maxlength="2" placeholder="F3"/></div>
<div class="cardin"><input data-slot="A3" maxlength="2" placeholder="T"/></div>
<div class="cardin"><input data-slot="A4" maxlength="2" placeholder="R"/></div>
</div>
</div>
<div class="board" id="boardB">
<h3>
<span>Board B</span>
<span class="controls">
<button class="btn" id="randB">ğŸ² Fill empties</button>
<button class="btn" id="randBFlop">ğŸ² Flop</button>
<button class="btn" id="randBTurn">ğŸ² Turn</button>
<button class="btn" id="randBRiver">ğŸ² River</button>
<button class="btn" id="clearB">âœ–ï¸ Clear</button>
</span>
</h3>
<div class="cards">
<div class="cardin"><input data-slot="B0" maxlength="2" placeholder="F1"/></div>
<div class="cardin"><input data-slot="B1" maxlength="2" placeholder="F2"/></div>
<div class="cardin"><input data-slot="B2" maxlength="2" placeholder="F3"/></div>
<div class="cardin"><input data-slot="B3" maxlength="2" placeholder="T"/></div>
<div class="cardin"><input data-slot="B4" maxlength="2" placeholder="R"/></div>
</div>
</div>
<div class="errbox" id="errorBox"></div>
<div class="progress"><div class="bar" id="bar"></div></div>
<div class="progress-row"><span id="progressLabel">0 / 0 (0%) â€¢ Remaining: 0</span></div>
<div id="selfTest"></div>
<div

    <!-- Betting helper: Pot odds / MDF / SPR -->


</div>
<!-- Right column: Results -->
<div class="panel results">
<h2 style="margin:8px">Results</h2>
<div style="margin:0 8px 6px; display:flex; justify-content:flex-start;">
  <label class="toggle" style="font-size:11px;">
    <input type="checkbox" id="singleBoardToggle">
    <span>Single-board mode (ignore Board B)</span>
  </label>
</div>
<div class="boards-out" id="resultsBoards" style="margin:8px"></div>
<div class="controls-extended" id="resultsFilters" style="margin:6px 0 8px; display:flex; justify-content:flex-end; gap:12px">
<!-- The two controls below will be moved here at runtime -->
<label class="toggle">
  <input type="checkbox" id="sortByEquity" />
  <span>Sort by equity</span>
</label>
</div>

<div class="tablewrap">
<table id="resultsTable">
<thead>
<tr>
<th>#</th>
<th>Hand</th>
<th>A: Wins</th>
<th>B: Wins</th>
<th>Total Eq</th>
<th>A: Winner</th>
<th>B: Winner</th>
<th>Scoop :)</th>
<th>1/4 :(</th>
<th class="col-chop">Chop</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>
<div id="winHandsSummary" style="font-size:12px;color:#9fb3c8;margin:6px 0 12px"></div>
<div class="board" id="betHelper" style="margin-top:10px;">
  <!-- <h3>
    Pot Odds / MDF / SPR
    <span style="font-size:11px;color:#9fb3c8;font-weight:400;margin-left:auto;">
      Quick bet-sizing cheat sheet
    </span>
  </h3>
  <div class="controls" style="margin-bottom:6px;">
    <label style="font-size:12px;color:#9fb3c8;">
      Pot
      <input id="poPot" type="number" min="0" step="0.1" placeholder="100" style="width:80px;">
    </label>
    <label style="font-size:12px;color:#9fb3c8;">
      Bet
      <input id="poBet" type="number" min="0" step="0.1" placeholder="66" style="width:80px;">
    </label>
    <label style="font-size:12px;color:#9fb3c8;">
      Eff. stack
      <input id="poStack" type="number" min="0" step="0.1" placeholder="300" style="width:90px;">
    </label>
    <button class="btn ghost" type="button" id="poClear">Clear</button>
  </div>

  <div id="poOutput"
       style="margin-top:6px;font-size:12px;color:#c8d4f0;line-height:1.4;">
    Enter pot + bet to see pot odds &amp; MDF.
  </div>
</div>

-->
</div>
</div>







  <!--


<!-- ========================= -->
<!--       HELP MODAL          -->
<!-- ========================= -->
<div id="helpModal"
     style="display:none; position:fixed; inset:0; z-index:9999;
            background:rgba(0,0,0,0.7); backdrop-filter:blur(4px);
            overflow:auto; padding:24px 12px;">
  <div style="max-width:840px; margin:32px auto; background:#050609;
              border-radius:16px; border:1px solid #223047;
              box-shadow:0 16px 40px rgba(0,0,0,0.8); padding:20px 16px 24px;">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
      <h2 style="margin:0; font-size:18px;">DBBP App Help &amp; Manual</h2>
      <button class="btn ghost" type="button"
              onclick="document.getElementById('helpModal').style.display='none'">
        âœ– Close
      </button>
    </div>

    <!-- VERSION TAG -->
    <div style="margin:0 0 16px; color:#9fb3c8; font-size:13px;">
      Version <strong>v1.1.2</strong>
    </div>

    <!-- ========================= -->
    <!--       HELP CONTENT        -->
    <!-- ========================= -->
    <div id="helpContent" style="max-height:70vh; overflow:auto; padding-right:4px;">

  <section>
    <h3>DBBP App â€” Help</h3>

    <h4>Basic workflow</h4>
    <ol>
      <li>
        <strong>Enter hands</strong><br>
        Blank seats are treated as <strong>random opponents</strong>.<br>
        To reduce players, use the <strong>player-count selector</strong>.<br>
        You can also randomize a single seat (ğŸ²), randomize empty seats, or randomize all seats.
      </li>
      <li>
        <strong>Enter boards (optional)</strong><br>
        You may enter a full board, flop/turn/river partials, or nothing (full random runout).
      </li>
    </ol>

    <h4>Modes</h4>

    <h5>V Exact (Omniscient â€” Full or Partial-Information)</h5>
    <p>
      Use V Exact for fully known hands, wildcards / constrained ranges, and partial-board situations.
      All card-removal and wildcard constraints are enforced on every trial.
      This mode answers: <em>&ldquo;What is the true showdown equity given everything we know?&rdquo;</em>
    </p>

    <h5>V Random (Range Simulation Mode)</h5>
    <p>
      Use V Random to:
    </p>
    <ul>
      <li>See <strong>every entered hand vs a random opponent range</strong></li>
      <li>Study <strong>multiple hands at once</strong></li>
      <li><strong>Compare performance of all hands across various board textures</strong></li>
    </ul>
    <p><strong>Requirements &amp; assumptions:</strong></p>
    <ul>
      <li>All seats must contain <strong>full, explicit hands</strong></li>
      <li><strong>Wildcards are not allowed</strong></li>
      <li>
        Each hand applies <strong>only its own card-removal effects</strong>: it does not assume
        knowledge of other players&rsquo; cards, and is evaluated as if opponents are drawn from a
        fresh random range consistent only with that hand.
      </li>
    </ul>
    <p>
      In other words: <em>each hand is tested independently vs a random field, not against the other entered hands.</em>
      This makes V Random best for range-vs-range and multi-hand exploration.
    </p>

    <h5>Single-Board Mode</h5>
    <p>
      Single-Board mode simulates only <strong>Board A</strong>. Board B is ignored in the simulation,
      its stats are hidden, and the Board B header shows <strong>&ldquo;n/a&rdquo;</strong> when empty.
      Saved scenarios remember whether Single-Board mode was on or off. Use this when studying regular single-board PLO.
    </p>

    <h4>Wildcards (V Exact only)</h4>
    <p>
      You can use wildcards to describe partial hands in V Exact:
    </p>
    <ul>
      <li><strong>AX</strong> &mdash; Ace of any suit</li>
      <li><strong>XS</strong> &mdash; any spade</li>
      <li><strong>XX</strong> &mdash; unknown card</li>
      <li><strong>!</strong> &mdash; NOT, as in !SS (No 2 Spades), !AA (No AA), !Kx etc.</li>
    </ul>
    <p>
      Wildcards obey card-removal rules, interact with other players&rsquo; cards, and are enforced every trial.
      Empty slots are shown as <strong>Xx</strong>. Wildcards are <strong>not permitted</strong> in V Random.
    </p>

    <h4>Running sims</h4>
    <p>
      Choose a trial count (10k&ndash;20k recommended for everyday work), then tap Run.
      You can cancel at any time to stop early.
    </p>

    <h4>Reading results</h4>

    <h5>Double-board mode</h5>
    <ul>
      <li><strong>A: Wins</strong> &mdash; equity on Board A</li>
      <li><strong>B: Wins</strong> &mdash; equity on Board B</li>
      <li><strong>Total Eq</strong> &mdash; combined equity across both boards</li>
      <li><strong>A: Winner</strong> &mdash; most common winning hand class on Board A</li>
      <li><strong>B: Winner</strong> &mdash; most common winning hand class on Board B</li>
      <li><strong>Scoop :)</strong> &mdash; wins both boards</li>
      <li><strong>1/4 :(</strong> &mdash; quartered percentage</li>
    </ul>
    <p>
      Winner fields show the <strong>most frequent showdown class</strong>, not abstract hand strength.
    </p>

    <h5>Single-board mode</h5>
    <ul>
      <li><strong>Total Eq</strong> &mdash; equity on Board A only</li>
      <li><strong>A: Winner</strong> &mdash; most common winning-hand class on Board A</li>
      <li><strong>Chop</strong> &mdash; percentage of tied-pot outcomes</li>
    </ul>
    <p>
      In Single-Board mode, Board B is ignored in sims, its columns are hidden, and its header shows <strong>&ldquo;n/a&rdquo;</strong> when empty.
      The <strong>Sort by equity</strong> toggle reorders the table by equity instead of seat number.
    </p>

    <h4>Save &amp; autosave</h4>
    <p>
      Saved scenarios include hands (with wildcards), boards A/B, card mode, view mode, board mode (single/double), and results.
      Autosave restores your last working state when you reopen the app.
    </p>

  </section>

</div>




<div id="bucketsModal"
     style="position:fixed;top:48px;inset:0;background:rgba(0,0,0,.85);z-index:200;display:none;">
  <button type="button"
          onclick="document.getElementById('bucketsModal').style.display='none'"
          style="position:absolute;top:40px;right:20px;z-index:210;border-radius:999px;border:1px solid rgba(255,255,255,.35);background:rgba(5,7,12,.9);color:#fff;padding:6px 10px;font-size:13px;cursor:pointer;">
    âœ– Close
  </button>

  <!-- Bucket tuner + example hands overlay -->
    <!-- Original buckets HTML in the background -->
  <iframe src="PLO_HAND_BUCKETS.html"
          style="position:absolute;inset:0;width:100%;height:100%;border:none;margin:0;padding:0;">
  </iframe>
</div>




<script>

// ---- Merged from earlier script ----
// ---------- Constants ----------
  const RANKS='23456789TJQKA';
  const SUITS='SHDC';
  const RANK_VAL=Object.fromEntries([...RANKS].map((r,i)=>[r,i]));
  const BUCKET_CFG = { broadwayWeight:1.0, dsWeight:1.0, gapPenalty:1.0 };
  const SUIT_SYM={S:'\u2660',H:'\u2665',D:'\u2666',C:'\u2663'}; // symbols
  const SUIT_CLASS={S:'s-spade',H:'s-heart',D:'s-diamond',C:'s-club'};

  // ---------- Helpers (main thread) ----------
// ---------- Card Mode (4/5/6) ----------
let CARDS_PER_HAND = 4;          // default PLO
let CURRENT_PLAYERS = 6;         // default players; will be clamped per mode
let SINGLE_BOARD_MODE = false;  // single-board PLO mode flag

function allowedSeatsFor(n){
  // Hard caps per card mode
  // PLO4 â†’ up to 9, PLO5 â†’ up to 8, PLO6 â†’ up to 7
  return n === 4 ? 9 :
         n === 5 ? 8 :
                    7;
}

// Valid player-count ranges per mode
function playersRangeFor(n){
  const max = allowedSeatsFor(n);
  return { min: 2, max };        // always at least 2 players
}

function examplePlaceholder(n){
  return n===4? "e.g. AS KD QC JH" :
         n===5? "e.g. AS KD QC JH 9D" :
                 "e.g. AS KD QC JH 9D 8C";
}

function updateSeatPlaceholders(){
  seatInputs.forEach(inp => { inp.placeholder = examplePlaceholder(CARDS_PER_HAND); });
}

// Keep CURRENT_PLAYERS in range whenever mode changes
function clampPlayersForMode(){
  const { min, max } = playersRangeFor(CARDS_PER_HAND);
  if (CURRENT_PLAYERS < min) CURRENT_PLAYERS = min;
  if (CURRENT_PLAYERS > max) CURRENT_PLAYERS = max;
}

// Build / refresh the players menu options based on current mode
function updateNumPlayersUI(){
  const sel = document.getElementById('numPlayersSelect');
  if (!sel) return;

  const { min, max } = playersRangeFor(CARDS_PER_HAND);

  // Preserve current choice if possible
  clampPlayersForMode();
  const current = CURRENT_PLAYERS;

  // Rebuild the list
  sel.innerHTML = '';
  for (let p = min; p <= max; p++) {
    const opt = document.createElement('option');
    opt.value = String(p);
    opt.textContent = p + ' players';
    if (p === current) opt.selected = true;
    sel.appendChild(opt);
  }
}

// Wire the dropdown once DOM is ready and seats exist
function initNumPlayersControl(){
  const sel = document.getElementById('numPlayersSelect');
  if (!sel) return;

  sel.addEventListener('change', () => {
    const v = parseInt(sel.value, 10);
    if (!isNaN(v)) {
      CURRENT_PLAYERS = v;
      clampPlayersForMode();
      enforceSeatLimit();   // re-enable/disable seats to match
    }
  });

  updateNumPlayersUI();
}
// --- helpers (drop these near your other helpers) ---
function isIOS() {
  // iPhone/iPad incl. iPadOS on M-series Macs with touch
  return /iP(hone|od|ad)/.test(navigator.platform) ||
         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}
function isMobileSafari() {
  const ua = navigator.userAgent;
  return /Safari/i.test(ua) && !/Chrome|CriOS|FxiOS|EdgiOS/i.test(ua) && (isIOS() || /Mobile\/\w+ Safari/i.test(ua));
}

// --- replacement export function ---

function enforceSeatLimit(){
  const seats = document.querySelectorAll('.seat');

  const maxByMode = allowedSeatsFor(CARDS_PER_HAND);
  clampPlayersForMode();
  const lim = Math.min(maxByMode, CURRENT_PLAYERS);

  seats.forEach((seatDiv, idx) => {
    const inp = seatDiv.querySelector('input[data-seat]');
    const over = (idx >= lim);
    seatDiv.classList.toggle('disabled', over);
    seatDiv.classList.toggle('collapsed', over);

    if (inp) {
      if (over) {
        inp.value = '';
        inp.disabled = true;
      } else {
        inp.disabled = false;
      }
    }
  });

  // Ensure randomizers skip disabled seats
  document.querySelectorAll('[data-rand-seat]').forEach(btn => {
    const i = parseInt(btn.getAttribute('data-rand-seat'), 10);
    btn.disabled = (i >= lim);
  });
  document.querySelectorAll('[data-clear-seat]').forEach(btn => {
    const i = parseInt(btn.getAttribute('data-clear-seat'), 10);
    btn.disabled = (i >= lim);
  });

  const status = document.getElementById('cardModeStatus');
  if (status) {
    const modeLabel =
      CARDS_PER_HAND === 4 ? 'Currently: PLO (4-card)' :
      CARDS_PER_HAND === 5 ? 'Currently: PLO5 (5-card)' :
                             'Currently: PLO6 (6-card)';
    status.textContent = modeLabel + ' â€¢ Players: ' + lim;
  }

  highlightDuplicates();
}
function setCardMode(n){
  CARDS_PER_HAND = n;

  // sync radios
  const r4 = document.getElementById('cardMode4'),
        r5 = document.getElementById('cardMode5'),
        r6 = document.getElementById('cardMode6');
  if (r4) r4.checked = (n === 4);
  if (r5) r5.checked = (n === 5);
  if (r6) r6.checked = (n === 6);

  // Clamp player count and refresh dropdown + seat limits
  clampPlayersForMode();
  updateNumPlayersUI();
  updateSeatPlaceholders();
  enforceSeatLimit();
}

  // Hook up listeners on DOMContentLoaded later
  
function normalizeCard(tok){
  if (!tok) return null;
  tok = String(tok).toUpperCase().trim();
  // Strip anything that's not rank/suit or X wildcard
  tok = tok.replace(/[^2-9TJQKASHDCX]/g, '');
  if (tok.length !== 2) return null;
  const r = tok[0];
  const s = tok[1];

  // Wildcard support: any token with X as rank or suit is treated as a placeholder,
  // not as a concrete card. We skip it and let the simulator randomize that slot.
  if (r === 'X' || s === 'X') return null;

  if (!(r in RANK_VAL) || !SUITS.includes(s)) return null;
  return r + s;
}

function parseHand(str){
  if (!str) return [];
  let t = String(str).toUpperCase();

  // Normalize common separators to spaces
  t = t.replace(/[,/|;-]+/g, ' ').trim();
  if (!t) return [];

  const out = [];

  if (t.includes(' ')) {
    const parts = t.split(/\s+/);
    for (const part of parts) {
      const c = normalizeCard(part);
      if (c) out.push(c);
    }
  } else {
    // Compact input like "ASKSQHJD" or "ASXXX" â€“ read as 2-char chunks.
    for (let i = 0; i + 1 < t.length; i += 2) {
      const c = normalizeCard(t.slice(i, i + 2));
      if (c) out.push(c);
    }
  }

  return out.slice(0, CARDS_PER_HAND);
}
function renderCardHTML(c){
  if(!c) return '';
  const r = c[0], s = c[1];
  return `<span class="cardchip ${SUIT_CLASS[s]||''}">${r}<span class="sym">${SUIT_SYM[s]||''}</span></span>`;
}
function handToHTML(h){ const sorted=[...h].sort((a,b)=>RANK_VAL[b[0]]-RANK_VAL[a[0]]); return `<div style="display:flex;align-items:center;gap:4px;">${sorted.map(renderCardHTML).join('')}</div>`; }
  
  // --- Wildcard-aware tokens for display & validation ---
  function parseTokensWithWildcards(raw, maxCards){
    const out = [];
    if (!raw) return out;

    const upper = String(raw).toUpperCase();
    // Keep only the characters we care about (ranks, suits, X, ! and whitespace/separators)
    // We'll extract NOT tokens first, then parse the remaining cards/wildcards as 2-char chunks.
    const kept = upper.replace(/[^2-9TJQKAXSHDC!\s,\/|;\-]/g, '');

    // 1) Extract NOT tokens (do not consume card slots)
    //   !AA  (no pair of A)  => max 1 A total in hand
    //   !SS  (no 2 spades)   => max 1 S total in hand
    //   !KX  (no K at all)   => 0 K total in hand
    const notRe = /!([2-9TJQKA])\1|!([SHDC])\2|!([2-9TJQKA])X/g;
    let m;
    const nots = [];
    while ((m = notRe.exec(kept)) !== null) {
      const tok = m[0]; // already uppercase
      nots.push({ kind:'not', code: tok });
    }

    // Remove NOT tokens then compact remaining to parse as 2-char chunks
    const cleaned = kept.replace(notRe, ' ').replace(/[^2-9TJQKAXSHDC]/g, '').trim();
    const limit = (typeof maxCards === 'number' && maxCards > 0) ? maxCards : 13;

    for (let i = 0; i + 1 < cleaned.length && out.length < limit; i += 2){
      const r = cleaned[i];
      const s = cleaned[i+1];
      if (RANKS.includes(r) && SUITS.includes(s)){
        out.push({ kind:'exact', rank:r, suit:s, code:r + s });
      } else if (RANKS.includes(r) && s === 'X'){
        out.push({ kind:'rankWild', rank:r, code:r + 'X' });
      } else if (r === 'X' && SUITS.includes(s)){
        out.push({ kind:'suitWild', suit:s, code:'X' + s });
      } else if (r === 'X' && s === 'X'){
        out.push({ kind:'anyWild', code:'XX' });
      }
    }

    // Always render NOT chips last (after the 4 cards)
    return out.concat(nots);
  }

  function renderTokenHTML(tok){
    if (!tok) return '';
    if (tok.kind === 'exact'){
      const s = tok.suit;
      const r = tok.rank;
      const cls = SUIT_CLASS[s] || '';
      const sym = SUIT_SYM[s] || '';
      return `<span class="cardchip ${cls}">${r}<span class="sym">${sym}</span></span>`;
    }
    if (tok.kind === 'rankWild'){
      // Rank-known wildcard: show as rank plus an "x" pictograph, e.g. Jx, Qx, Xx.
      const r = (tok.rank || 'X').toUpperCase();
      return `<span class="cardchip cardchip-wild"><span>${r}</span><span class="sym sym-x">x</span></span>`;
    }
    if (tok.kind === 'suitWild'){
      // Suit-known wildcard: display as "X" plus the suit pictograph, e.g. Xâ™¥
      const s = tok.suit;
      const cls = SUIT_CLASS[s] || '';
      const sym = SUIT_SYM[s] || '';
      return `<span class="cardchip cardchip-wild ${cls}"><span>X</span><span class="sym">${sym}</span></span>`;
    }
    if (tok.kind === 'anyWild'){
      // Fully unknown wildcard: display as Xx with an "x" pictograph.
      return `<span class="cardchip cardchip-wild"><span>X</span><span class="sym sym-x">x</span></span>`;
    }
    if (tok.kind === 'not'){
      return `<span class="cardchip cardchip-not">${tok.code}</span>`;
    }
    return '';
  }

  function tokensToHTML(tokens){
    // Always display up to CARDS_PER_HAND cards.
    // If the user partially enters a hand, pad the rest with Xx (anyWild)
    // purely for visual consistency.
    const arr = Array.isArray(tokens) ? [...tokens] : [];
    const cards = arr.filter(t => t && t.kind !== 'not');
    const nots  = arr.filter(t => t && t.kind === 'not');

    try {
      while (cards.length < CARDS_PER_HAND) {
        cards.push({ kind:'anyWild', code:'XX' });
      }
    } catch (e) {}

    const htmlCards = cards.length ? cards.map(renderTokenHTML).join('') : '';
    const htmlNots  = nots.length  ? nots.map(renderTokenHTML).join('')  : '';
    const combined = htmlCards + htmlNots;
    if (!combined) return '';
    return `<div style="display:flex;align-items:center;gap:4px;">${combined}</div>`;
  }

  function fullDeck(){
    const d = [];
    for (const r of RANKS){
      for (const s of SUITS){
        d.push(r + s);
      }
    }
    return d;
  }

function removeFromDeck(deck,cards){ for(const c of cards){ const i=deck.indexOf(c); if(i>=0) deck.splice(i,1); } }

  // Collect all text inputs in the app (seats, boards, scenario fields, etc.)
const allTextInputs = [...document.querySelectorAll('input[type="text"], input:not([type])')];

// --- iOS/Safari stale form-restore fix ---
// Safari sometimes restores old autofilled values from BFCache when reopening the app.
// We want a clean slate at startup, so wipe all text inputs once on load.
allTextInputs.forEach(inp => {
    inp.value = '';
});

// Board inputs (kept for references elsewhere in the code)
const boardSlots = [...document.querySelectorAll('.cardin input')];

function getBoardInputs(prefix) {
    return [0,1,2,3,4].map(i =>
        document.querySelector(`input[data-slot="${prefix}${i}"]`)
    );
}

  // ---------- UI refs & seats ----------
  const seatsEl=document.getElementById('seats');
  const resultsBody=document.querySelector('#resultsTable tbody');
  const omniscientToggle=document.getElementById('omniscientToggle');
  const viewModeSelect=document.getElementById('viewModeSelect');
  function isOmniscientMode(){
    return viewModeSelect ? viewModeSelect.value === 'exact' : false;
  }
  function setOmniscientMode(on){
    if (!viewModeSelect) return;
    viewModeSelect.value = on ? 'exact' : 'random';
  }

  const rangeModeToggle=document.getElementById('rangeModeToggle');
  const errorBox=document.getElementById('errorBox');
  const bar=document.getElementById('bar');
  const progressLabel=document.getElementById('progressLabel');
  const cancelBtn=document.getElementById('cancelBtn');
  function disableClearButtons() {
    document.querySelectorAll('[data-clear-seat]').forEach(btn => { btn.disabled = true; });
    const clearA = document.getElementById('clearA');
    if (clearA) clearA.disabled = true;
    const clearB = document.getElementById('clearB');
    if (clearB) clearB.disabled = true;
  }

  function enableClearButtons() {
    document.querySelectorAll('[data-clear-seat]').forEach(btn => { btn.disabled = false; });
    const clearA = document.getElementById('clearA');
    if (clearA) clearA.disabled = false;
    const clearB = document.getElementById('clearB');
    if (clearB) clearB.disabled = false;
  }

  let RANGE_MODE=false;


  
const MAX = 9;
const seatInputs = [];
const bucketGroups = [];

for (let i = 0; i < MAX; i++) {
  const d = document.createElement('div');
  d.className = 'seat';
  d.innerHTML = `
    <h4>
      <span>Seat ${i + 1}</span>
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
        <!-- Range-mode bucketGroup UI removed -->
        <button class="btn" data-rand-seat="${i}" title="Randomize this seat">ğŸ²</button>
        <button class="btn ghost" data-clear-seat="${i}" title="Clear this seat">âœ–ï¸</button>
      </div>
    </h4>
    <input placeholder="e.g. AS KD QC JH" data-seat="${i}">
  `;
  seatsEl.appendChild(d);
  seatInputs.push(d.querySelector('input'));
  bucketGroups.push(d.querySelector('.bucketGroup'));
}

function getBucketsForSeat(idx) {
  const grp = bucketGroups[idx];
  if (!grp) return [];
  const out = [];
  grp.querySelectorAll('.bucketBtn.active').forEach(btn => {
    const v = parseInt(btn.getAttribute('data-bucket'), 10);
    if (!isNaN(v)) out.push(v);
  });
  return out;
}

function markBucketSeats() {
  seatInputs.forEach((inp, idx) => {
    const seatDiv = inp.closest ? inp.closest('.seat') : null;
    if (!seatDiv) return;
    const buckets = getBucketsForSeat(idx);
    if (RANGE_MODE && buckets.length > 0) {
      seatDiv.classList.add('range-bucket');
    } else {
      seatDiv.classList.remove('range-bucket');
    }
  });
}



function serializeSeatBuckets() {
  return bucketGroups.map(grp => {
    if (!grp) return [];
    const selected = [];
    grp.querySelectorAll('.bucketBtn').forEach(btn => {
      if (btn.classList.contains('active')) {
        const v = parseInt(btn.getAttribute('data-bucket'), 10);
        if (!isNaN(v)) selected.push(v);
      }
    });
    return selected;
  });
}

function applySeatBuckets(snapshotBuckets) {
  if (!Array.isArray(snapshotBuckets)) {
    bucketGroups.forEach(grp => {
      if (!grp) return;
      grp.querySelectorAll('.bucketBtn.active').forEach(btn => {
        btn.classList.remove('active');
      });
    });
    markBucketSeats();
    return;
  }

  bucketGroups.forEach((grp, idx) => {
    if (!grp) return;
    const wanted = snapshotBuckets[idx] || [];
    grp.querySelectorAll('.bucketBtn').forEach(btn => {
      const v = parseInt(btn.getAttribute('data-bucket'), 10);
      if (!isNaN(v) && wanted.includes(v)) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  });

  markBucketSeats();
}

if (typeof rangeModeToggle !== 'undefined' && rangeModeToggle) {
  rangeModeToggle.addEventListener('change', () => {
    RANGE_MODE = !!rangeModeToggle.checked;
    document.body.classList.toggle('range-mode-on', RANGE_MODE);
    markBucketSeats();
  });
}

bucketGroups.forEach(grp => {
  if (!grp) return;
  grp.addEventListener('click', ev => {
    const btn = ev.target.closest('.bucketBtn');
    if (!btn) return;
    btn.classList.toggle('active');
    markBucketSeats();
  });
});



// ---------- Duplicate detection ----------

  // Concrete-card usage (exact cards only)
  function allTypedMap(){
    const map = {};
    const add = c => {
      if (!c) return;
      map[c] = (map[c] || 0) + 1;
    };
    // Seats
    seatInputs.forEach(inp => {
      parseHand(inp.value).forEach(add);
    });
    // Boards
    boardSlots.forEach(inp => {
      const c = normalizeCard(inp.value);
      if (c) add(c);
    });
    return map;
  }

  // Rank / suit demand from wildcards + exact cards
  function collectConstraintNeeds(){
    const rankNeed = {};
    const suitNeed = {};
    let totalSlots = 0;

    function addExact(card){
      if (!card) return;
      const r = card[0];
      const s = card[1];
      if (r) rankNeed[r] = (rankNeed[r] || 0) + 1;
      if (s) suitNeed[s] = (suitNeed[s] || 0) + 1;
      totalSlots += 1;
    }

    function addFromRaw(raw){
      if (!raw) return;
      // exact typed cards
      parseHand(raw).forEach(addExact);

      // wildcard-style constraints
      if (typeof buildHandHintFromRaw === 'function'){
        const hint = buildHandHintFromRaw(raw, CARDS_PER_HAND);
        if (hint){
          if (Array.isArray(hint.rankWilds)){
            hint.rankWilds.forEach(r => {
              if (!r) return;
              rankNeed[r] = (rankNeed[r] || 0) + 1;
              totalSlots += 1;
            });
          }
          if (Array.isArray(hint.suitWilds)){
            hint.suitWilds.forEach(s => {
              if (!s) return;
              suitNeed[s] = (suitNeed[s] || 0) + 1;
              totalSlots += 1;
            });
          }
          if (typeof hint.anyWilds === 'number' && hint.anyWilds > 0){
            totalSlots += hint.anyWilds;
          }
        }
      }
    }

    seatInputs.forEach(inp => addFromRaw(inp.value));
    boardSlots.forEach(inp => addFromRaw(inp.value));

    return { rankNeed, suitNeed, totalSlots };
  }

  function highlightDuplicates(){
    // 1) Strict duplicate concrete cards
    const used = allTypedMap();
    const dups = new Set(Object.keys(used).filter(k => used[k] > 1));

    // Clear dup flags first
    seatInputs.forEach(inp => inp.classList.remove('dup'));
    boardSlots.forEach(inp => inp.classList.remove('dup'));

    // Mark any inputs that contain a duplicated concrete card
    if (dups.size){
      seatInputs.forEach(inp => {
        const h = parseHand(inp.value);
        if (h.some(c => dups.has(c))) inp.classList.add('dup');
      });
      boardSlots.forEach(inp => {
        const c = normalizeCard(inp.value);
        if (c && dups.has(c)) inp.classList.add('dup');
      });
    }

    const errors = [];

    if (dups.size){
      errors.push('ğŸš« Duplicate concrete cards: ' +
        [...dups].map(c => `<code>${c}</code>`).join(' '));
    }

    // 2) Impossible rank / suit requirements (taking wildcards into account)
    const needs = collectConstraintNeeds();
    const rankNeed = needs.rankNeed;
    const suitNeed = needs.suitNeed;

    const impossibleRanks = Object.keys(rankNeed).filter(r => rankNeed[r] > 4);
    const impossibleSuits = Object.keys(suitNeed).filter(s => suitNeed[s] > 13);

    impossibleRanks.forEach(r => {
      errors.push(`ğŸš« Impossible combo: more than 4 ${r}s required (need ${rankNeed[r]})`);
    });

    impossibleSuits.forEach(s => {
      const label = {S:'spades',H:'hearts',D:'diamonds',C:'clubs'}[s] || s;
      errors.push(`ğŸš« Impossible combo: more than 13 ${label} required (need ${suitNeed[s]})`);
    });

    if (impossibleRanks.length || impossibleSuits.length){
      function touchesImpossible(raw){
        if (!raw) return false;
        const exact = parseHand(raw);
        if (exact.some(c =>
          (impossibleRanks.includes(c[0])) ||
          (impossibleSuits.includes(c[1]))
        )) return true;

        if (typeof buildHandHintFromRaw === 'function'){
          const hint = buildHandHintFromRaw(raw, CARDS_PER_HAND);
          if (hint){
            if (Array.isArray(hint.rankWilds) &&
                hint.rankWilds.some(r => impossibleRanks.includes(r))) {
              return true;
            }
            if (Array.isArray(hint.suitWilds) &&
                hint.suitWilds.some(s => impossibleSuits.includes(s))) {
              return true;
            }
          }
        }
        return false;
      }

      seatInputs.forEach(inp => {
        if (touchesImpossible(inp.value)) inp.classList.add('dup');
      });
      boardSlots.forEach(inp => {
        if (touchesImpossible(inp.value)) inp.classList.add('dup');
      });
    }

    if (errors.length){
      errorBox.classList.add('show');
      errorBox.innerHTML = errors.join('<br>');
    } else {
      errorBox.classList.remove('show');
      errorBox.innerHTML = '';
    }
  }

  seatInputs.forEach(inp => inp.addEventListener('input', highlightDuplicates));
  boardSlots.forEach(inp => inp.addEventListener('input', highlightDuplicates));

// Seats: only active seats should ever be touched by randomizers
function isSeatEnabled(i){
  const maxByMode = allowedSeatsFor(CARDS_PER_HAND);
  clampPlayersForMode();
  const lim = Math.min(maxByMode, CURRENT_PLAYERS);

  const inp = seatInputs[i];
  if (!inp) return false;
  const seatDiv = inp.closest('.seat');
  return i < lim && !inp.disabled && !(seatDiv && seatDiv.classList.contains('disabled'));
}


  
// ---- Seat-level rank/suit needs (for board randomizers & constraints) ----
function collectSeatNeeds(){
  const rankNeed = {};
  const suitNeed = {};

  function addFromRaw(raw){
    if (!raw) return;
    const exact = parseHand(raw) || [];
    exact.forEach(card => {
      if (!card || card.length !== 2) return;
      const r = card[0];
      const s = card[1];
      if (r) rankNeed[r] = (rankNeed[r] || 0) + 1;
      if (s) suitNeed[s] = (suitNeed[s] || 0) + 1;
    });

    if (typeof buildHandHintFromRaw === 'function'){
      const hint = buildHandHintFromRaw(raw, CARDS_PER_HAND);
      if (hint){
        if (Array.isArray(hint.rankWilds)){
          hint.rankWilds.forEach(r => {
            if (!r) return;
            rankNeed[r] = (rankNeed[r] || 0) + 1;
          });
        }
        if (Array.isArray(hint.suitWilds)){
          hint.suitWilds.forEach(s => {
            if (!s) return;
            suitNeed[s] = (suitNeed[s] || 0) + 1;
          });
        }
        // anyWilds doesn't constrain a specific rank or suit, so we skip it here
      }
    }
  }

  seatInputs.forEach(inp => addFromRaw(inp.value));
  return { rankNeed, suitNeed };
}

// ---------- Randomizers ----------
  function allUsedCards(except=[]) { const u=[]; seatInputs.forEach(inp=> u.push(...parseHand(inp.value))); boardSlots.forEach(inp=>{ const c=normalizeCard(inp.value); if(c) u.push(c); }); return u.filter(c=>!except.includes(c)); }
  function randomSeatHand(except=[]) {
  const deck = fullDeck();
  // Remove all already-used concrete cards, except any explicitly allowed (for rerolls)
  removeFromDeck(deck, allUsedCards(except));

  // Also respect seat constraints (wildcards) just like board randomizers:
  // if seats already "use up" all copies of a rank or suit, don't allow those
  // cards to appear in newly randomized hands.
  let needs = null;
  try {
    if (typeof collectSeatNeeds === 'function') {
      needs = collectSeatNeeds();
    }
  } catch (e) {
    needs = null;
  }

  if (needs) {
    const rankNeed = needs.rankNeed || {};
    const suitNeed = needs.suitNeed || {};

    // Remove ranks fully consumed by seats (e.g., 4 aces -> no aces left)
    Object.keys(rankNeed).forEach(r => {
      if (rankNeed[r] >= 4) {
        for (let i = deck.length - 1; i >= 0; i--) {
          if (deck[i][0] === r) deck.splice(i, 1);
        }
      }
    });

    // Remove suits fully consumed (rare, but consistent)
    Object.keys(suitNeed).forEach(s => {
      if (suitNeed[s] >= 13) {
        for (let i = deck.length - 1; i >= 0; i--) {
          if (deck[i][1] === s) deck.splice(i, 1);
        }
      }
    });
  }

  return takeN(deck, CARDS_PER_HAND);
}
  function setSeat(i,c) { seatInputs[i].value=c.join(' '); }
  function fillRandomEmptySeats(){
  for(let i=0;i<seatInputs.length;i++){
    if(!isSeatEnabled(i)) continue;                        // NEW: skip disabled/over-limit seats
    if(parseHand(seatInputs[i].value).length===0){
      setSeat(i, randomSeatHand());
    }
  }
  highlightDuplicates();
}

function randomizeAllSeats(){
  const deck = fullDeck();

  // keep boards; remove already typed cards from deck
  boardSlots.forEach(inp=>{
    const c = normalizeCard(inp.value);
    if(c){
      const k = deck.indexOf(c);
      if(k>=0) deck.splice(k,1);
    }
  });

  // clear ONLY active seats
  for(let i=0;i<seatInputs.length;i++){
    if(!isSeatEnabled(i)) continue;                        // NEW
    seatInputs[i].value = '';
    // Clear chip display right away
    const out = seatInputs[i].parentElement && seatInputs[i].parentElement.querySelector('.chipout');
    if (out) out.innerHTML = '';
    // Re-apply auto-Xx logic (this seat will stay blank because userCleared=1)
    if (typeof applyAutoXxToOtherSeats === 'function') applyAutoXxToOtherSeats();
    if (typeof renderSeatChips === 'function') renderSeatChips();
  }

  // deal ONLY to active seats
  for(let i=0;i<seatInputs.length;i++){
    if(!isSeatEnabled(i)) continue;                        // NEW
    const h = takeN(deck, CARDS_PER_HAND);
    setSeat(i, h);
  }

  highlightDuplicates();
}

function rerollSeat(idx){
  if(!isSeatEnabled(idx)) return;                          // NEW: ignore disabled seat buttons
  const prev = parseHand(seatInputs[idx].value);
  const h = randomSeatHand(prev);
  setSeat(idx, h);
  highlightDuplicates();
}

  function takeN(deck, n){ const out=new Array(n); for(let k=0;k<n;k++){ const j=(Math.random()*deck.length)|0; const last=deck.length-1; const pick=deck[j]; deck[j]=deck[last]; deck.length=last; out[k]=pick; } return out; }
  function randomizeBoard(prefix){
  const inputs = getBoardInputs(prefix);
  let deck = fullDeck();
  // Remove any concrete cards already used anywhere (seats + both boards)
  removeFromDeck(deck, allUsedCards());

  // Seat constraints (rank/suit needs) so board randomization doesn't make seats impossible
  let needs = null;
  try { if (typeof collectSeatNeeds === 'function') needs = collectSeatNeeds(); } catch(e){ needs = null; }

  const rankNeed = (needs && needs.rankNeed) ? needs.rankNeed : {};
  const suitNeed = (needs && needs.suitNeed) ? needs.suitNeed : {};

  // Count concrete cards already fixed on BOTH boards (A+B), because those are already removed from deck
  const fixedBoards = [];
  (getBoardInputs('A')||[]).forEach(inp=>{ const c=normalizeCard(inp.value); if(c) fixedBoards.push(c); });
  (getBoardInputs('B')||[]).forEach(inp=>{ const c=normalizeCard(inp.value); if(c) fixedBoards.push(c); });

  const boardRankCount = {};
  const boardSuitCount = {};
  fixedBoards.forEach(c=>{
    const r=c[0], s=c[1];
    boardRankCount[r]=(boardRankCount[r]||0)+1;
    boardSuitCount[s]=(boardSuitCount[s]||0)+1;
  });

  // Helper: can we place this candidate card on the board without making seat needs impossible?
  function okCandidate(c){
    const r=c[0], s=c[1];
    const rCount = (boardRankCount[r]||0) + 1;
    const sCount = (boardSuitCount[s]||0) + 1;
    // Rank capacity: seats need rankNeed[r] and boards already have rCount must be <= 4
    const needR = (rankNeed && rankNeed[r]) ? rankNeed[r] : 0;
    if (needR + rCount > 4) return false;
    // Suit capacity: seats need suitNeed[s] and boards already have sCount must be <= 13
    const needS = (suitNeed && suitNeed[s]) ? suitNeed[s] : 0;
    if (needS + sCount > 13) return false;
    return true;
  }

  // Preserve any pre-typed board cards, then fill remaining slots with safe draws.
  // First, ensure any concrete card already in THIS board is removed from deck (should already be, but safe).
  inputs.forEach(inp=>{
    const c = normalizeCard(inp.value);
    if (c){
      const i = deck.indexOf(c);
      if (i >= 0) deck.splice(i,1);
    }
  });

  for (const inp of inputs){
    if (normalizeCard(inp.value)) continue;

    // Try a handful of random candidates that satisfy okCandidate().
    let picked = null;
    for (let tries=0; tries<200; tries++){
      if (!deck.length) break;
      const j = (Math.random()*deck.length)|0;
      const c = deck[j];
      if (!okCandidate(c)) continue;
      picked = c;
      // remove from deck
      deck.splice(j,1);
      // update counts
      const r=c[0], s=c[1];
      boardRankCount[r]=(boardRankCount[r]||0)+1;
      boardSuitCount[s]=(boardSuitCount[s]||0)+1;
      break;
    }

    // Fallback: scan for the first valid candidate (deterministic) if random tries didn't find one
    if (!picked){
      for (let j=0; j<deck.length; j++){
        const c = deck[j];
        if (!okCandidate(c)) continue;
        picked = c;
        deck.splice(j,1);
        const r=c[0], s=c[1];
        boardRankCount[r]=(boardRankCount[r]||0)+1;
        boardSuitCount[s]=(boardSuitCount[s]||0)+1;
        break;
      }
    }

    if (picked) inp.value = picked;
  }

  highlightDuplicates();
}
function clearBoard(prefix){ getBoardInputs(prefix).forEach(inp=> inp.value=''); highlightDuplicates(); }
  function randomizeStreet(prefix, idxs){
  const inputs = getBoardInputs(prefix);
  const deck = fullDeck();
  removeFromDeck(deck, allUsedCards());

  let needs = null;
  try {
    if (typeof collectSeatNeeds === 'function') {
      needs = collectSeatNeeds();
    }
  } catch (e) {
    needs = null;
  }

  if (needs) {
    const rankNeed = needs.rankNeed || {};
    const suitNeed = needs.suitNeed || {};

    Object.keys(rankNeed).forEach(r => {
      if (rankNeed[r] >= 4) {
        for (let i = deck.length - 1; i >= 0; i--) {
          if (deck[i][0] === r) deck.splice(i, 1);
        }
      }
    });

    Object.keys(suitNeed).forEach(s => {
      if (suitNeed[s] >= 13) {
        for (let i = deck.length - 1; i >= 0; i--) {
          if (deck[i][1] === s) deck.splice(i, 1);
        }
      }
    });
  }

  idxs.forEach(i => {
    const [c] = takeN(deck, 1);
    inputs[i].value = c;
  });
  highlightDuplicates();
}
document.getElementById('randEmptySeats').addEventListener('click', fillRandomEmptySeats);
  document.getElementById('randAllSeats').addEventListener('click', randomizeAllSeats);
  document.querySelectorAll('[data-rand-seat]').forEach(btn=> btn.addEventListener('click', ()=>{ const i=parseInt(btn.getAttribute('data-rand-seat')); rerollSeat(i); }));
document.querySelectorAll('[data-clear-seat]').forEach(btn =>
  btn.addEventListener('click', () => {
    const i = parseInt(btn.getAttribute('data-clear-seat'));
    // v1.1.1: treat Clear button like manual deletion (do not auto-regenerate Xx)
    if (seatInputs[i].dataset) {
      seatInputs[i].dataset.userCleared = '1';
      delete seatInputs[i].dataset.autofilled;
    }
    seatInputs[i].value = '';

    // Clear any active buckets for this seat
    if (typeof bucketGroups !== 'undefined') {
      const grp = bucketGroups[i];
      if (grp) {
        grp.querySelectorAll('.bucketBtn.active').forEach(b => b.classList.remove('active'));
      }
    }
    if (typeof markBucketSeats === 'function') {
      markBucketSeats();
    }
    highlightDuplicates();
  })
);

  document.getElementById('randA').addEventListener('click', ()=> randomizeBoard('A'));
  document.getElementById('randB').addEventListener('click', ()=> randomizeBoard('B'));
  document.getElementById('clearA').addEventListener('click', ()=> clearBoard('A'));
  document.getElementById('clearB').addEventListener('click', ()=> clearBoard('B'));
  document.getElementById('randAFlop').addEventListener('click', ()=> randomizeStreet('A',[0,1,2]));
  document.getElementById('randATurn').addEventListener('click', ()=> randomizeStreet('A',[3]));
  document.getElementById('randARiver').addEventListener('click', ()=> randomizeStreet('A',[4]));
  document.getElementById('randBFlop').addEventListener('click', ()=> randomizeStreet('B',[0,1,2]));
  document.getElementById('randBTurn').addEventListener('click', ()=> randomizeStreet('B',[3]));
  document.getElementById('randBRiver').addEventListener('click', ()=> randomizeStreet('B',[4]));

  // ---------- Web Workers (parallel simulation, one per CPU core) ----------
  let simWorkers=[]; let workerURL=null;
  function buildWorker(){
    const src=`(function(){
      const RANKS='23456789TJQKA';
      const SUITS='SHDC';
      const RANK_VAL=Object.fromEntries([...RANKS].map((r,i)=>[r,i]));
      let BUCKET_CFG = { broadwayWeight:1.0, dsWeight:1.0, gapPenalty:1.0 };

      // --- Xoshiro-family PRNG (xoshiro128**-style) for fast, high-quality RNG ---
      let _rngS0 = 0 | 0, _rngS1 = 0 | 0, _rngS2 = 0 | 0, _rngS3 = 0 | 0;

      function _rngRotl(x, k){
        return ((x << k) | (x >>> (32 - k))) | 0;
      }

      function _rngSplitMix32(x){
        x = (x | 0) + 0x9E3779B9 | 0;
        let z = x;
        z ^= z >>> 16;
        z = (z * 0x85EBCA6B) | 0;
        z ^= z >>> 13;
        z = (z * 0xC2B2AE35) | 0;
        z ^= z >>> 16;
        return z | 0;
      }

      function _rngSeedFromInt(seed){
        seed = seed | 0;
        _rngS0 = _rngSplitMix32(seed);
        _rngS1 = _rngSplitMix32(seed + 1 | 0);
        _rngS2 = _rngSplitMix32(seed + 2 | 0);
        _rngS3 = _rngSplitMix32(seed + 3 | 0);
      }

      function _rngNext(){
        const result = (_rngRotl((_rngS1 * 5) | 0, 7) * 9) | 0;
        const t = (_rngS1 << 9) | 0;

        _rngS2 ^= _rngS0;
        _rngS3 ^= _rngS1;
        _rngS1 ^= _rngS2;
        _rngS0 ^= _rngS3;
        _rngS2 ^= t;
        _rngS3 = _rngRotl(_rngS3, 11);

        return result >>> 0;
      }

      function _rngNextFloat(){
        // Scale 32-bit int to [0,1)
        return _rngNext() / 4294967296;
      }

      function fullDeck(){ const d=[]; for(const r of RANKS) for(const s of SUITS) d.push(r+s); return d; }
      function removeFromDeck(deck,cards){ for(const c of cards){ const i=deck.indexOf(c); if(i>=0) deck.splice(i,1); } }
      function takeN(deck, n){ const out=new Array(n); for(let k=0;k<n;k++){ const j=(_rngNextFloat()*deck.length)|0; const last=deck.length-1; const pick=deck[j]; deck[j]=deck[last]; deck.length=last; out[k]=pick; } return out; }

      function buildHand2Combos(n){ const out=[]; for(let i=0;i<n;i++) for(let j=i+1;j<n;j++) out.push([i,j]); return out; }
      let HAND2_COMBOS = [];
      const BOARD3_COMBOS=(()=>{const out=[]; for(let a=0;a<3;a++) for(let b=a+1;b<4;b++) for(let c=b+1;c<5;c++) out.push([a,b,c]); return out;})();

      function eval5(cards){
        const rv=[cards[0][0],cards[1][0],cards[2][0],cards[3][0],cards[4][0]].map(r=>RANK_VAL[r]).sort((a,b)=>b-a);
        const s0=cards[0][1], flush=(cards[1][1]===s0 && cards[2][1]===s0 && cards[3][1]===s0 && cards[4][1]===s0);
        const u=[...new Set(rv)];
        let straight=false, top=-1;
        if(u.includes(12)&&u.includes(3)&&u.includes(2)&&u.includes(1)&&u.includes(0)){ straight=true; top=3; }
        for(let i=12;i>=4;--i){ if(u.includes(i)&&u.includes(i-1)&&u.includes(i-2)&&u.includes(i-3)&&u.includes(i-4)){ straight=true; top=i; break; } }
        const cnt={}; for(const r of rv){cnt[r]=(cnt[r]||0)+1}
        const groups=Object.entries(cnt).map(([r,c])=>({r:parseInt(r),c})).sort((a,b)=> b.c===a.c ? b.r-a.r : b.c-a.c);
        if(flush&&straight) return [8,top];
        if(groups[0].c===4) return [7,groups[0].r,groups[1].r];
        if(groups[0].c===3 && groups[1] && groups[1].c===2) return [6,groups[0].r,groups[1].r];
        if(flush) return [5,...rv];
        if(straight) return [4,top];
        if(groups[0].c===3){ const kick=groups.filter(g=>g.c===1).map(g=>g.r).sort((a,b)=>b-a); return [3,groups[0].r,...kick]; }
        if(groups[0].c===2 && groups[1] && groups[1].c===2){ const hi=Math.max(groups[0].r,groups[1].r), lo=Math.min(groups[0].r,groups[1].r); const k=groups.find(g=>g.c===1)?.r ?? -1; return [2,hi,lo,k]; }
        if(groups[0].c===2){ const k=groups.filter(g=>g.c===1).map(g=>g.r).sort((a,b)=>b-a); return [1,groups[0].r,...k]; }
        return [0,...rv];
      }
      function cmpRank(a,b){ const n=Math.max(a.length,b.length); for(let i=0;i<n;i++){ const A=a[i]??-1, B=b[i]??-1; if(A>B) return 1; if(A<B) return -1; } return 0; }

      // UPDATED: return flags for Set and Quads-with-pocket-pair only
      function bestOmaha5(handN,board5){
        let best=null; // {rank:Array, isSet:boolean, isQuadPocket:boolean}
        for(let i=0;i<HAND2_COMBOS.length;i++){
          const hi=HAND2_COMBOS[i][0], hj=HAND2_COMBOS[i][1];
          const h1=handN[hi], h2=handN[hj];
          for(let j=0;j<10;j++){
            const b=BOARD3_COMBOS[j];
            const five=[h1,h2,board5[b[0]],board5[b[1]],board5[b[2]]];
            const r=eval5(five);
            if(!best || cmpRank(r,best.rank)>0){
              let isSet=false, isQuadPocket=false;
              if(r[0]===3){
                const tripRank=r[1];
                const hRanks=[h1[0],h2[0]].map(x=>RANK_VAL[x]);
                isSet=(hRanks[0]===tripRank && hRanks[1]===tripRank);
              }
              if(r[0]===7){ // quads
                const quadRank=r[1];
                const hRanks=[h1[0],h2[0]].map(x=>RANK_VAL[x]);
                isQuadPocket=(hRanks[0]===quadRank && hRanks[1]===quadRank);
              }
              best={rank:r,isSet,isQuadPocket};
            }
          }
        }
        return best;
      }

      function resolveBoardWinners(board, handList){
        let bestRank=null, ties=[]; const n=handList.length;
        let bestIsSet=false, bestIsQuadPocket=false;
        for(let p=0;p<n;p++){
          if(abort){ postMessage({type:'aborted'}); return; }
          const res=bestOmaha5(handList[p], board);
          const rank=res.rank;
          if(!bestRank || cmpRank(rank,bestRank)>0){
            bestRank=rank; ties=[p]; bestIsSet=!!res.isSet; bestIsQuadPocket=!!res.isQuadPocket;
          } else if(cmpRank(rank,bestRank)===0){
            ties.push(p);
            if(rank[0]===3 && res.isSet) bestIsSet=true;
            if(rank[0]===7 && res.isQuadPocket) bestIsQuadPocket=true;
          }
        }
        // 10 buckets: High,Pair,Two Pair,Trips,Set,Straight,Flush,Full House,Quads,Straight Flush
        let labelIndex=0;
        if(bestRank){
          const cat=bestRank[0];
          if(cat===0) labelIndex=0;
          else if(cat===1) labelIndex=1;
          else if(cat===2) labelIndex=2;
          else if(cat===3) labelIndex = bestIsSet ? 4 : 3;
          else if(cat===4) labelIndex=5;
          else if(cat===5) labelIndex=6;
          else if(cat===6) labelIndex=7;
          else if(cat===7) labelIndex=8;          
          else if(cat===8) labelIndex=9;
        }
        return {ties, share:1/(ties.length||1), cat:labelIndex};
      }

      let abort=false;
      onmessage=(e)=>{
        const {type}=e.data;
        if(type==='cancel'){ abort=true; return; }
        if(type==='run'){
          const handSize = e.data.handSize || 4;
          HAND2_COMBOS = buildHand2Combos(handSize);
          abort=false;
          const seed = (e.data.rngSeed|0) >>> 0;
          _rngSeedFromInt(seed);
          const {hands,fixedA,fixedB,trials,subjective,progressEvery,partialEvery,handHints}=e.data;
          const singleBoardMode = !!e.data.singleBoardMode;
          const rangeMode = !!e.data.rangeMode;
          const rangeMeta = e.data.rangeMeta || null;
          if (e.data.bucketCfg) {
            BUCKET_CFG.broadwayWeight = e.data.bucketCfg.broadwayWeight || 1.0;
            BUCKET_CFG.dsWeight       = e.data.bucketCfg.dsWeight || 1.0;
            BUCKET_CFG.gapPenalty     = e.data.bucketCfg.gapPenalty || 1.0;
          } else {
            BUCKET_CFG.broadwayWeight = 1.0;
            BUCKET_CFG.dsWeight       = 1.0;
            BUCKET_CFG.gapPenalty     = 1.0;
          }
          const n=hands.length;
          const hints = Array.isArray(handHints) ? handHints : [];
          const winsA=new Array(n).fill(0), winsB=new Array(n).fill(0);
          const chops=new Array(n).fill(0), scoops=new Array(n).fill(0), quarters=new Array(n).fill(0);
          const winClassA=new Array(10).fill(0), winClassB=new Array(10).fill(0);

          // per-player distributions of likely winning hand categories (A/B)
          const winClassAByP=Array.from({length:n},()=>new Array(10).fill(0));
          const winClassBByP=Array.from({length:n},()=>new Array(10).fill(0));

          const unitsPerTrial=subjective? n:1; let unitsDone=0;
          const chunk=Math.max(500,(trials/10)|0);

          
          
          function oneOmniscient(){
            // Start from a fresh deck of 52 cards
            const deck = fullDeck();

            // Remove any fixed board cards and exact seat cards from the deck up front.
            // This guarantees they can't be drawn again when resolving wildcards or boards.
            const dead = [];
            for (const c of fixedA) dead.push(c);
            if (!singleBoardMode) {
              for (const c of fixedB) dead.push(c);
            }
            for (const h of hands) {
              for (const c of h) dead.push(c);
            }
            removeFromDeck(deck, dead);

            // Precompute rank availability and remaining required ranks so unconstrained seats
            // can't "steal" cards needed to satisfy later rank-wild constraints (e.g. Kx Kx).
            const _rIdx = (r)=>RANKS.indexOf(r);
            const deckRankCounts = new Array(RANKS.length).fill(0);
            for (let i=0;i<deck.length;i++){ deckRankCounts[_rIdx(deck[i][0])]++; }
            const remainingNeedRank = new Array(RANKS.length).fill(0);
            const hintsAll = Array.isArray(handHints) ? handHints : [];
            for (let i=0;i<hintsAll.length;i++){
              const hw = hintsAll[i];
              if (hw && Array.isArray(hw.rankWilds)){
                for (let j=0;j<hw.rankWilds.length;j++){
                  const rr = hw.rankWilds[j];
                  const ri = _rIdx(rr);
                  if (ri>=0) remainingNeedRank[ri]++;
                }
              }
            }

            // For omniscient sims with partial hands and wildcard syntax (Xs, Ax, xx)
            const drawnHands = new Array(hands.length);

            // Randomize seat order each trial so no seat gets systematic priority
            const order = [];
            for (let i = 0; i < hands.length; i++) order.push(i);
            for (let t = order.length - 1; t > 0; t--) {
              const j = (_rngNextFloat() * (t + 1)) | 0;
              const tmp = order[t];
              order[t] = order[j];
              order[j] = tmp;
            }

            let omniFailed = false;

            // First, fully realize all player hands subject to wildcard constraints.
            for (const idx of order) {
              const base = hands[idx].slice();
              let need = handSize - base.length;
              if (need <= 0) {
                drawnHands[idx] = base;
                continue;
              }

              const hint = (Array.isArray(hints) && hints[idx]) ? hints[idx] : {};
              const rankWilds = Array.isArray(hint.rankWilds) ? hint.rankWilds : [];
              const suitWilds = Array.isArray(hint.suitWilds) ? hint.suitWilds : [];
              let anyWilds = typeof hint.anyWilds === 'number' ? hint.anyWilds : 0;

              const notRankPairs = Array.isArray(hint.notRankPairs) ? hint.notRankPairs : [];
              const notSuitPairs = Array.isArray(hint.notSuitPairs) ? hint.notSuitPairs : [];
              const notRankZero  = Array.isArray(hint.notRankZero)  ? hint.notRankZero  : [];

              

              // Remove this seat's rank requirements from the "remaining" pool so we only protect
              // ranks needed by seats not yet dealt.
              for (let _k=0; _k<rankWilds.length; _k++){
                const _ri = _rIdx(rankWilds[_k]);
                if (_ri>=0) remainingNeedRank[_ri]--;
              }
function _countRank(arr, r){
                let c=0; for (let i=0;i<arr.length;i++){ if (arr[i][0]===r) c++; } return c;
              }
              function _countSuit(arr, s){
                let c=0; for (let i=0;i<arr.length;i++){ if (arr[i][1]===s) c++; } return c;
              }
              function _allowedWithNot(baseCards, cand){
                const r = cand[0], s = cand[1];

                // Rank totally forbidden: !Kx
                for (let i=0;i<notRankZero.length;i++){
                  if (notRankZero[i] === r) return false;
                }

                // Rank cannot pair: !AA => max 1 A
                for (let i=0;i<notRankPairs.length;i++){
                  const rr = notRankPairs[i];
                  if (rr === r && _countRank(baseCards, r) >= 1) return false;
                }

                // Suit cannot double: !SS => max 1 S
                for (let i=0;i<notSuitPairs.length;i++){
                  const ss = notSuitPairs[i];
                  if (ss === s && _countSuit(baseCards, s) >= 1) return false;
                }

                return true;
              }


              // Rank-constrained wildcards: "Ax" â†’ any suit, rank A
              for (const r of rankWilds) {
                if (need <= 0 || deck.length === 0) break;
                let found = -1;
                for (let i = 0; i < deck.length; i++) {
                  if (deck[i][0] === r && _allowedWithNot(base, deck[i])) { found = i; break; }
                }
                if (found === -1) { omniFailed = true; break; }
                const pick = deck[found];
                deck[found] = deck[deck.length - 1];
                deck.length = deck.length - 1;
                base.push(pick);
                deckRankCounts[_rIdx(pick[0])]--; 
                need--;
              }

              if (omniFailed) break;

              // Suit-constrained wildcards: "Xs" â†’ any rank, suit S
              for (const s of suitWilds) {
                if (need <= 0 || deck.length === 0) break;
                let found = -1;
                for (let i = 0; i < deck.length; i++) {
                  if (deck[i][1] === s && _allowedWithNot(base, deck[i])) { found = i; break; }
                }
                if (found === -1) { omniFailed = true; break; }
                const pick = deck[found];
                deck[found] = deck[deck.length - 1];
                deck.length = deck.length - 1;
                base.push(pick);
                deckRankCounts[_rIdx(pick[0])]--; 
                need--;
              }

              if (omniFailed) break;

              // Fully unconstrained wildcards: "xx" etc.
              while (need > 0 && anyWilds > 0 && deck.length > 0) {
                // Try a few times to find a card that satisfies NOT constraints
                let pickIdx = -1;
                for (let tries = 0; tries < 24; tries++) {
                  const idx2 = (Math.random() * deck.length) | 0;
                  const cand = deck[idx2];
                  if (_allowedWithNot(base, cand)) {
                      const _ri2 = _rIdx(cand[0]);
                      if (_ri2>=0 && (deckRankCounts[_ri2]-1) < remainingNeedRank[_ri2]) { continue; }
                      pickIdx = idx2; break;
                    }
                }
                if (pickIdx === -1) { omniFailed = true; break; }
                const idx2 = pickIdx;
                const pick = deck[idx2];
                deck[idx2] = deck[deck.length - 1];
                deck.length = deck.length - 1;
                base.push(pick);
                deckRankCounts[_rIdx(pick[0])]--; 
                need--;
                anyWilds--;
              }

              // If we still need more cards after consuming all wildcard tokens,
              // fill the remainder randomly (these slots were unconstrained).
              if (need > 0 && deck.length > 0) {
                const extra = [];
                for (let _t=0; _t<need; _t++){
                  let pickIdx = -1;
                  for (let tries=0; tries<64; tries++){
                    const idx2 = (_rngNextFloat() * deck.length) | 0;
                    const cand = deck[idx2];
                    const _ri2 = _rIdx(cand[0]);
                    if (_ri2>=0 && (deckRankCounts[_ri2]-1) < remainingNeedRank[_ri2]) continue;
                    if (!_allowedWithNot(base, cand)) continue;
                    pickIdx = idx2; break;
                  }
                  if (pickIdx === -1) { omniFailed = true; break; }
                  const pick = deck[pickIdx];
                  deck[pickIdx] = deck[deck.length - 1];
                  deck.length = deck.length - 1;
                  deckRankCounts[_rIdx(pick[0])]--;
                  extra.push(pick);
                }
                if (omniFailed) break;
                base.push(...extra);
                need = 0;
              }

              // If we somehow still couldn't fill the hand, treat this trial as invalid.
              if (need > 0) {
                omniFailed = true;
                break;
              }

              drawnHands[idx] = base;
            }

            if (omniFailed) {
              // Skip this trial entirely â€“ it's incompatible with the global deck
              return;
            }

            // Now that all player hands are locked in, deal the remaining unknown board cards.
            const boardA = fixedA.slice();
            const boardB = fixedB.slice();
            if (boardA.length < 5) boardA.push(...takeN(deck, 5 - boardA.length));
            if (!singleBoardMode && boardB.length < 5) {
              boardB.push(...takeN(deck, 5 - boardB.length));
            }

            const a = resolveBoardWinners(boardA, drawnHands);
            const b = singleBoardMode ? null : resolveBoardWinners(boardB, drawnHands);

            if (a && typeof a.cat === 'number') winClassA[a.cat]++;
            if (!singleBoardMode && b && typeof b.cat === 'number') winClassB[b.cat]++;

            if (a) {
              for (const p of a.ties) {
                winsA[p] += a.share;
                if (typeof a.cat === 'number') winClassAByP[p][a.cat] += a.share;
              }
            }
            if (b) {
              for (const p of b.ties) {
                winsB[p] += b.share;
                if (typeof b.cat === 'number') winClassBByP[p][b.cat] += b.share;
              }
            }

            for (let p = 0; p < hands.length; p++) {
              const wonA = a && a.ties.includes(p);
              const wonB = b && b.ties.includes(p);

              // Pure scoop: wins both boards outright (no ties on either board)
              if (!singleBoardMode && wonA && wonB && a && b && a.ties.length === 1 && b.ties.length === 1) {
                scoops[p]++;
              }
              // Quarter: wins exactly one quarter of the pot (2-way split on one board, loses the other)
              else if (
                !singleBoardMode && (
                  (wonA && a && a.ties.length === 2 && !wonB) ||
                  (wonB && b && b.ties.length === 2 && !wonA)
                )
              ) {
                quarters[p]++;
              }

              // Chop: any time this seat ties with one or more other players
              const tiedOnA = a && a.ties && a.ties.length > 1 && a.ties.includes(p);
              const tiedOnB = !singleBoardMode && b && b.ties && b.ties.length > 1 && b.ties.includes(p);
              if (tiedOnA || tiedOnB) {
                chops[p]++;
              }
            }
          }



          function oneSubjective(){
  // Build SUBJECTIVE summary once per trial (boards + active player count only)
  try {
    const dBoards = fullDeck();
    removeFromDeck(dBoards, singleBoardMode ? [...fixedA] : [...fixedA, ...fixedB]);
    const boardASum = fixedA.slice();
    if (boardASum.length < 5) boardASum.push(...takeN(dBoards, 5 - boardASum.length));
    const boardBSum = singleBoardMode ? [] : fixedB.slice();
    if (!singleBoardMode && boardBSum.length < 5) boardBSum.push(...takeN(dBoards, 5 - boardBSum.length));

    const dSum = fullDeck();
    removeFromDeck(dSum, singleBoardMode ? [...boardASum] : [...boardASum, ...boardBSum]);
    const randHands = [];
    let activeCount = 0;
    for (let p = 0; p < hands.length; p++) {
      const active = Array.isArray(hands[p]) && hands[p].length === handSize;
      if (active) { randHands.push(takeN(dSum, handSize)); activeCount++; }
    }
    if (activeCount < 2) throw null; // skip meaningless case
    const aS = resolveBoardWinners(boardASum, randHands);
    const bS = singleBoardMode ? null : resolveBoardWinners(boardBSum, randHands);
    if (aS && typeof aS.cat === 'number' && winClassA[aS.cat] != null) winClassA[aS.cat]++;
    if (!singleBoardMode && bS && typeof bS.cat === 'number' && winClassB[bS.cat] != null) winClassB[bS.cat]++;
  } catch (_) { /* swallow & continue trial */ }

  // Then run per-hero simulations
  for (let hero = 0; hero < hands.length; hero++) {
    const heroActive = Array.isArray(hands[hero]) && hands[hero].length === handSize;
    if (!heroActive) continue;
    if (abort) { postMessage({ type:'aborted' }); return; }

    const deckHero = fullDeck();
    removeFromDeck(deckHero, singleBoardMode ? [...hands[hero], ...fixedA] : [...hands[hero], ...fixedA, ...fixedB]);
    const boardA = fixedA.slice();
    if (boardA.length < 5) boardA.push(...takeN(deckHero, 5 - boardA.length));
    const boardB = singleBoardMode ? [] : fixedB.slice();
    if (!singleBoardMode && boardB.length < 5) boardB.push(...takeN(deckHero, 5 - boardB.length));

    const deckOpp = fullDeck();
    removeFromDeck(deckOpp, singleBoardMode ? [...hands[hero], ...boardA] : [...hands[hero], ...boardA, ...boardB]);
    const oppHands = [hands[hero]];
    for (let p = 0; p < hands.length; p++) {
      if (p === hero) continue;
      const active = Array.isArray(hands[p]) && hands[p].length === handSize;
      if (!active) continue;
      oppHands.push(takeN(deckOpp, handSize));
    }

    const a = resolveBoardWinners(boardA, oppHands);
    const b = singleBoardMode ? null : resolveBoardWinners(boardB, oppHands);
    const heroWonA = a.ties.includes(0);
    const heroWonB = b && b.ties ? b.ties.includes(0) : false;
    if (heroWonA) {
      winsA[hero] += a.share;
      if (typeof a.cat === 'number') winClassAByP[hero][a.cat] += a.share;
    }
    if (heroWonB) {
      winsB[hero] += b.share;
      if (typeof b.cat === 'number') winClassBByP[hero][b.cat] += b.share;
    }
    const wonA = heroWonA, wonB = heroWonB;
    if (!singleBoardMode && wonA && wonB && a.ties.length === 1 && b.ties.length === 1) scoops[hero]++;
    if (
      !singleBoardMode && (
        (wonA && a.ties.length === 2 && !wonB) ||
        (wonB && b.ties.length === 2 && !wonA)
      )
    ) {
      quarters[hero]++;
    }

    // Chop: any time hero ties with one or more other players
    const tiedOnA = a && a.ties && a.ties.length > 1 && a.ties.includes(0);
    const tiedOnB = !singleBoardMode && b && b.ties && b.ties.length > 1 && b.ties.includes(0);
    if (tiedOnA || tiedOnB) {
      chops[hero]++;
    }
  }
}



          

         // ---- Bucket-based strength heuristics for range mode ----
function analyzeHandForBucket(hand){
  const n = hand.length;
  const ranks = hand.map(c => RANK_VAL[c[0]]).sort((a,b) => b - a); // high to low

  // Suits & suit histograms
  const suits = hand.map(c => c[1]);
  const suitCounts = {};
  for (const s of suits) {
    suitCounts[s] = (suitCounts[s] || 0) + 1;
  }
  let maxSuitCount = 0;
  for (const s in suitCounts) {
    if (suitCounts[s] > maxSuitCount) maxSuitCount = suitCounts[s];
  }

  // How many suits have 2+ cards (true DS vs just "suited")
  const twoPlusSuitCount = Object.values(suitCounts).filter(c => c >= 2).length;
  const doubleSuited = twoPlusSuitCount >= 2;   // TRUE DS
  const singleSuited = twoPlusSuitCount === 1;  // exactly one suit with 2+ cards

  // Rank histogram / pairs / trips / quads
  const rankCounts = {};
  for (const r of ranks) {
    rankCounts[r] = (rankCounts[r] || 0) + 1;
  }
  let pairs = 0, trips = 0, quads = 0, highestPairRank = -1;
  for (const rStr in rankCounts) {
    const c = rankCounts[rStr];
    const r = parseInt(rStr, 10);
    if (c === 2) {
      pairs++;
      highestPairRank = Math.max(highestPairRank, r);
    } else if (c === 3) {
      trips++;
      highestPairRank = Math.max(highestPairRank, r);
    } else if (c === 4) {
      quads++;
      highestPairRank = Math.max(highestPairRank, r);
    }
  }

  const hasAce = ranks.includes(RANK_VAL['A']); // 12
  const broadway = ranks.filter(r => r >= RANK_VAL['T']).length; // T,J,Q,K,A

  // Gap sum + connected run
  let gapSum = 0;
  for (let i = 0; i < ranks.length - 1; i++) {
    gapSum += Math.max(0, (ranks[i] - ranks[i + 1] - 1));
  }
  const connectedRun = (() => {
    let best = 1, cur = 1;
    for (let i = 0; i < ranks.length - 1; i++) {
      if (ranks[i] - ranks[i + 1] <= 1) cur++;
      else cur = 1;
      if (cur > best) best = cur;
    }
    return best;
  })();

  return {
    n,
    ranks,
    maxSuitCount,
    pairs,
    trips,
    quads,
    highestPairRank,
    hasAce,
    broadway,
    gapSum,
    connectedRun,
    doubleSuited,
    singleSuited
  };
}

        // Map hand features to bucket 1..5 (1 = strongest, 5 = weakest)

      // Map hand features to bucket 1..5 (1 = strongest, 5 = weakest),
      // using a simple weighted score that the sliders can adjust.
      function classifyBucketFromFeatures(info){
        const high    = info.ranks[0];
        const isDS    = !!info.doubleSuited;   // true double-suited only
        const isSS    = !!info.singleSuited;   // exactly one suit with >=2
        const hasAce  = !!info.hasAce;

        const strongPair = info.pairs >= 1 && info.highestPairRank >= RANK_VAL['T']; // TT+
        const anyPair    = info.pairs >= 1 || info.trips >= 1 || info.quads >= 1;

        // Feature scores (these are what the sliders indirectly modulate)
        const dsScore   = isDS ? 2.0 * BUCKET_CFG.dsWeight : 0;    // DS gets boosted
        const ssScore   = isSS ? 1.0 * BUCKET_CFG.dsWeight : 0;    // SS gets some weight
        const bwScore   = info.broadway * BUCKET_CFG.broadwayWeight; // # of Broadway cards
        const gapAdj    = info.gapSum / 2;                          // normalize a bit
        const connScore = info.connectedRun - BUCKET_CFG.gapPenalty * gapAdj;
        const pairScore = strongPair ? 2.0 : (anyPair ? 1.0 : 0.0);
        const aceScore  = hasAce ? 0.75 : 0.0;
        const highScore = (high / 12) * 1.0;                        // 0â€“1 based on top rank

        // Composite â€œrawâ€ strength score
        const raw = dsScore + ssScore + bwScore + connScore + pairScore + aceScore + highScore;

        // Rough bucket thresholds (you can tweak these if you want)
        if (raw >= 7.5) return 1;    // premium
        if (raw >= 5.5) return 2;    // strong
        if (raw >= 3.75) return 3;   // solid / playable
        if (raw >= 2.0) return 4;    // marginal / speculative
        return 5;                    // trash
      }
function classifyBucket(hand){
            const info = analyzeHandForBucket(hand);
            return classifyBucketFromFeatures(info);
          }

          function drawBucketHand(deck, handSize, targetBucket){
            if(!targetBucket || targetBucket<=0){
              return takeN(deck, handSize);
            }
            // Try limited attempts to find a hand in the desired bucket
            for(let attempt=0; attempt<32; attempt++){
              const cand = takeN(deck, handSize);
              const b = classifyBucket(cand);
              if(b === targetBucket){
                return cand;
              }
              // Put cards back and try again (approximate but fine for Monte Carlo)
              for(const c of cand){ deck.push(c); }
            }
            // Fallback if we can't hit target bucket cleanly
            return takeN(deck, handSize);
          }

                    function oneRange(){
            // Range-vs-range mode: players with buckets (or empty hands in range mode)
            // are treated as fresh random hands each trial; exact hands stay fixed.

            const deck = fullDeck();

            // --- 1) Precompute which seats are fixed exact hands in range mode ---
            const exactActiveFlags = new Array(hands.length).fill(false);
            const exactCards = [];

            for (let p = 0; p < hands.length; p++) {
              const base = hands[p];
              const meta = rangeMeta && rangeMeta[p] ? rangeMeta[p] : null;
              const exactActive =
                Array.isArray(base) &&
                base.length === handSize &&
                (!meta || meta.hasExact);

              if (exactActive) {
                exactActiveFlags[p] = true;
                for (const c of base) exactCards.push(c);
              }
            }

            // --- 2) Remove any fixed cards (exact hands + fixed board stubs) BEFORE
            //         we finish dealing out random board cards. This prevents
            //         duplication like AAAA also appearing on the board.
            removeFromDeck(deck, [...exactCards, ...fixedA, ...fixedB]);

            // --- 3) Build full boards from the cleaned deck ---
            const boardA = fixedA.slice();
            if (boardA.length < 5) {
              boardA.push(...takeN(deck, 5 - boardA.length));
            }

            const boardB = fixedB.slice();
            if (boardB.length < 5) {
              boardB.push(...takeN(deck, 5 - boardB.length));
            }

            // Remove fully realized boards from the deck so ranges can't reuse board cards
            removeFromDeck(deck, [...boardA, ...boardB]);

            // --- 4) Deal hands: exact seats reuse their fixed hands; range seats
            //         draw bucket hands from the remaining deck.
            const drawHands = [];
            for (let p = 0; p < hands.length; p++) {
              const base = hands[p];
              const meta = rangeMeta && rangeMeta[p] ? rangeMeta[p] : null;
              let h;

              if (exactActiveFlags[p]) {
                // Exact hand already removed from the deck above
                h = base.slice();
              } else {
                let bucketIdx = 0;
                if (meta && Array.isArray(meta.buckets) && meta.buckets.length > 0) {
                  const pick = ((_rngNextFloat() * meta.buckets.length) | 0);
                  bucketIdx = meta.buckets[pick];
                }
                h = drawBucketHand(deck, handSize, bucketIdx);
              }
              drawHands.push(h);
            }

            // --- 5) Resolve winners + classification, unchanged from your current code ---
            const a = resolveBoardWinners(boardA, drawHands);
            const b = resolveBoardWinners(boardB, drawHands);
            if (a && typeof a.cat === 'number') winClassA[a.cat]++;
            if (b && typeof b.cat === 'number') winClassB[b.cat]++;

            for (const p of (a ? a.ties : [])) {
              winsA[p] += a.share;
              if (typeof a.cat === 'number') winClassAByP[p][a.cat] += a.share;
            }
            for (const p of (b ? b.ties : [])) {
              winsB[p] += b.share;
              if (typeof b.cat === 'number') winClassBByP[p][b.cat] += b.share;
            }
            for (let p = 0; p < drawHands.length; p++) {
              const wonA = a && a.ties.includes(p);
              const wonB = b && b.ties.includes(p);
              if ((wonA || wonB) && !(wonA && wonB)) chops[p]++;
              if (wonA && wonB && a && b && a.ties.length === 1 && b.ties.length === 1) scoops[p]++;
              if (
                (wonA && a && a.ties.length === 2 && !wonB) ||
                (wonB && b && b.ties.length === 2 && !wonA)
              ) {
                quarters[p]++;
              }
            }
          }

let t=0; 
          function snapshotStats(trialsSoFar){
            return {
              winsA:[...winsA], winsB:[...winsB],
              chops:[...chops], scoops:[...scoops], quarters:[...quarters],
              trials: Math.max(1, trialsSoFar|0),
              winClassA:[...winClassA], winClassB:[...winClassB],
              winClassAByP: winClassAByP.map(row=>[...row]),
              winClassBByP: winClassBByP.map(row=>[...row]),
            };
          }
const progStep=Math.max(1,progressEvery|0); const partStep = Math.max(1, partialEvery|0);
          while(t<trials){
            if(abort){ postMessage({type:'aborted'}); return; }
            const end=Math.min(trials,t+chunk);
            for(;t<end;t++){
              if(abort){ postMessage({type:'aborted'}); return; }
              rangeMode ? oneRange() : (subjective? oneSubjective(): oneOmniscient());
              unitsDone+=unitsPerTrial;
              if ((t % progStep) === 0) postMessage({ type: 'progress', unitsDone });
              if ((t % partStep) === 0) postMessage({ type: 'partial', stats: snapshotStats(t || 1) });

            }
          }
          postMessage({type:'done',stats:{winsA,winsB,chops,scoops,quarters,trials,winClassA,winClassB,winClassAByP,winClassBByP}});
        }
      };
    })();`;
    const blob=new Blob([src],{type:'application/javascript'});
    workerURL=URL.createObjectURL(blob);
    return new Worker(workerURL);
  }

  function killWorker(){
    simWorkers.forEach(w=>{ try{ w.terminate(); }catch(_){} });
    simWorkers=[];
    if(workerURL){ URL.revokeObjectURL(workerURL); workerURL=null; }
  }

  
  // ---------- Study features (Quiz / Sort / Scenarios) ----------

  // ---------- Preloaded 8-way DBBP Templates ----------
  const DBBP_TEMPLATES = [
  {
    "name": "FD on both boards (Hero double\u2011suited)",
    "hero": "As Ks Qd Jd",
    "A": [
      "Ts",
      "7s",
      "2h"
    ],
    "B": [
      "9d",
      "4d",
      "2c"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Top set on straighty board (JT9) + overpair on other",
    "hero": "Jh Jc Ad Kd",
    "A": [
      "Js",
      "Td",
      "9c"
    ],
    "B": [
      "6s",
      "3d",
      "2h"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Nut wrap + NFD on A-9-8 two\u2011tone",
    "hero": "Ks Qs Jd Td",
    "A": [
      "As",
      "9s",
      "8h"
    ],
    "B": [
      "7d",
      "3c",
      "2c"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Made nut flush (monotone) + weak backdoors other board",
    "hero": "Ad Kd 9c 9s",
    "A": [
      "Qd",
      "7d",
      "4d"
    ],
    "B": [
      "Tc",
      "8h",
      "4s"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Paired both boards; flopped quads",
    "hero": "7h 7c Ac Kc",
    "A": [
      "7d",
      "7s",
      "3h"
    ],
    "B": [
      "Qs",
      "Qd",
      "2d"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "AA double\u2011suited vs dynamic + low board",
    "hero": "As Ad Ks Qd",
    "A": [
      "Jc",
      "Tc",
      "9d"
    ],
    "B": [
      "6h",
      "4h",
      "2s"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Second\u2011nut FD + blockers other board",
    "hero": "Kh Qh Ac 5d",
    "A": [
      "Jh",
      "8h",
      "3s"
    ],
    "B": [
      "Kc",
      "9d",
      "4c"
    ],
    "omn": false,
    "trials": "10000"
  },
  {
    "name": "Premium DS rundown; NFD on one board + top pair on other",
    "hero": "As Ks Qd Jd",
    "A": [
      "5s",
      "6d",
      "7s"
    ],
    "B": [
      "Kc",
      "Tc",
      "2d"
    ],
    "omn": false,
    "trials": "10000"
  }
];

  function populateTemplates() {
    const sel = document.getElementById('templateList');
    if(!sel) return;
    sel.innerHTML = '<option value="">Templatesâ€¦</option>' + DBBP_TEMPLATES.map((t,idx)=>`<option value="${idx}">${t.name}</option>`).join('');
  }

  function applyTemplate(idx) {
    const t = DBBP_TEMPLATES[+idx];
    if(!t) return;
    // Seat 1 hero, seats 2-8 blank (random)
    if(seatInputs[0]) seatInputs[0].value = t.hero;
    for(let i=1;i<seatInputs.length;i++) if(seatInputs[i]) seatInputs[i].value = '';
    // Boards
    for(let i=0;i<5;i++) {
      const aEl = document.querySelector(`input[data-slot="A${i}"]`);
      const bEl = document.querySelector(`input[data-slot="B${i}"]`);
      if(aEl) aEl.value = t.A[i] || '';
      if(bEl) bEl.value = t.B[i] || '';
    }
    // Mode & trials
    if(typeof t.omn === 'boolean') setOmniscientMode(t.omn);
    if(t.trials && document.getElementById('trials')) document.getElementById('trials').value = t.trials;
    highlightDuplicates();
  enforceSeatLimit(); updateSeatPlaceholders();
  }

  document.addEventListener('DOMContentLoaded', ()=> {
    populateTemplates();
    const btn = document.getElementById('loadTemplate');
    const sel = document.getElementById('templateList');
    if(btn && sel) btn.addEventListener('click', ()=>{ if(sel.value!=='') applyTemplate(sel.value); });
  });
  let QUIZ_ACTIVE = false;
  let QUIZ_REVEALED = false;
  const quizToggleBtn = () => document.getElementById('quizToggle');
  const quizRevealBtn = () => document.getElementById('quizReveal');
  const quizStatus = () => document.getElementById('quizStatus');
  const sortByEquityEl = () => document.getElementById('sortByEquity');
  const bucketFilterEl = () => document.getElementById('bucketFilter');

  // Stored last stats & labels to support re-render on sort/filter/reveal
  let _lastStats=null, _lastLabels=null, _lastBoardA=[], _lastBoardB=[];

  function toggleQuiz(){
    QUIZ_ACTIVE = !QUIZ_ACTIVE;
    QUIZ_REVEALED = false;
    if(quizToggleBtn()){
      quizToggleBtn().classList.toggle('primary', QUIZ_ACTIVE);
      quizToggleBtn().textContent = QUIZ_ACTIVE ? 'ğŸ§  Quiz ON' : 'ğŸ§  Quiz Mode';
    }
    if(quizRevealBtn()) quizRevealBtn().disabled = !QUIZ_ACTIVE;
    if(quizStatus()) quizStatus().style.display = QUIZ_ACTIVE ? 'inline-block' : 'none';
    if(_lastStats){ updateResults(_lastLabels,_lastStats,_lastBoardA,_lastBoardB); }
  }
  function revealQuiz(){
    if(!QUIZ_ACTIVE) return;
    QUIZ_REVEALED = true;
    if(_lastStats){ updateResults(_lastLabels,_lastStats,_lastBoardA,_lastBoardB); }
  }

  if(document.getElementById('quizToggle')) document.getElementById('quizToggle').addEventListener('click', toggleQuiz);
  if(document.getElementById('quizReveal')) document.getElementById('quizReveal').addEventListener('click', revealQuiz);
  if(sortByEquityEl()) sortByEquityEl().addEventListener('change', ()=>{ if(_lastStats) updateResults(_lastLabels,_lastStats,_lastBoardA,_lastBoardB); });
  if(bucketFilterEl()) bucketFilterEl().addEventListener('change', ()=>{ if(_lastStats) updateResults(_lastLabels,_lastStats,_lastBoardA,_lastBoardB); });

  // Scenario helpers
  
// Scenario helpers â€” IndexedDB (replaces localStorage)
const SC_KEY = 'dbbp_scenarios_v1'; // legacy key name kept for compatibility

function readScenarioState(){
  const seats = seatInputs.map(inp => inp.value);
  const A = [0,1,2,3,4].map(i=>document.querySelector(`input[data-slot="A${i}"]`).value||'');
  const B = [0,1,2,3,4].map(i=>document.querySelector(`input[data-slot="B${i}"]`).value||'');
  const omn = isOmniscientMode();
  const trials = document.getElementById('trials') ? document.getElementById('trials').value : '5000';
  const mode = CARDS_PER_HAND;
  const players = CURRENT_PLAYERS;
  const rangeMode = !!RANGE_MODE;
  const seatBuckets = (typeof serializeSeatBuckets === 'function')
    ? serializeSeatBuckets()
    : null;

  // Also snapshot the most recent sim results (if any) so that
  // loading a scenario restores the full results view, not just
  // the inputs.
  let results = null;
  try {
    if (typeof _lastStats !== 'undefined' &&
        _lastStats &&
        typeof _lastLabels !== 'undefined' &&
        _lastLabels) {
      results = {
        labels: _lastLabels,
        stats: _lastStats,
        boardA: _lastBoardA,
        boardB: _lastBoardB
      };
    }
  } catch (e) {
    console.warn('Unable to capture last results for scenario save', e);
  }

  const singleBoardMode = !!SINGLE_BOARD_MODE;
  return {seats,A,B,omn,trials,mode,players,rangeMode,seatBuckets,results,singleBoardMode};
}

function applyScenario(sc){
  if(!sc) return;
  if (typeof sc.mode === 'number' && sc.mode !== CARDS_PER_HAND) {
    setCardMode(sc.mode);
  }
  if (typeof sc.players === 'number') {
    CURRENT_PLAYERS = sc.players;
    if (typeof clampPlayersForMode === 'function') clampPlayersForMode();
    if (typeof updateNumPlayersUI === 'function') updateNumPlayersUI();
  }
  (sc.seats||[]).forEach((v,i)=>{ if(seatInputs[i]) seatInputs[i].value=v; });
  (sc.A||[]).forEach((v,i)=>{ const el=document.querySelector(`input[data-slot="A${i}"]`); if(el) el.value=v; });
  (sc.B||[]).forEach((v,i)=>{ const el=document.querySelector(`input[data-slot="B${i}"]`); if(el) el.value=v; });

  if (typeof sc.rangeMode === 'boolean') {
    RANGE_MODE = sc.rangeMode;
    if (typeof rangeModeToggle !== 'undefined' && rangeModeToggle) {
      rangeModeToggle.checked = RANGE_MODE;
    }
    document.body.classList.toggle('range-mode-on', RANGE_MODE);
  }

  if (Array.isArray(sc.seatBuckets) && typeof applySeatBuckets === 'function') {
    applySeatBuckets(sc.seatBuckets);
  } else if (typeof applySeatBuckets === 'function') {
    applySeatBuckets(null);
  }


  if (typeof sc.singleBoardMode === 'boolean') {
    SINGLE_BOARD_MODE = sc.singleBoardMode;
    const sbToggle = document.getElementById('singleBoardToggle');
    if (sbToggle) {
      sbToggle.checked = SINGLE_BOARD_MODE;
    }

    // Pin result semantics to the scenario's board mode
    if (typeof RESULTS_SINGLE_BOARD === 'undefined') {
      window.RESULTS_SINGLE_BOARD = !!sc.singleBoardMode;
    } else {
      RESULTS_SINGLE_BOARD = !!sc.singleBoardMode;
    }

    // Re-render last results (if any) so they reflect this board mode
    if (typeof updateResults === 'function' &&
        window._lastLabels && window._lastStats) {
      updateResults(
        window._lastLabels,
        window._lastStats,
        window._lastBoardA || [],
        window._lastBoardB || []
      );
    }
  }
  if(typeof sc.omn==='boolean') setOmniscientMode(sc.omn);
  if(sc.trials && document.getElementById('trials')) document.getElementById('trials').value = sc.trials;
  if (typeof highlightDuplicates === 'function') highlightDuplicates();
  if (typeof enforceSeatLimit === 'function') enforceSeatLimit();
  if (typeof updateSeatPlaceholders === 'function') updateSeatPlaceholders();

  // If this scenario captured a previous sim result, restore it now
  // so the results table / boards / likely-winning-hand rows come
  // back along with the inputs.
  if (sc.results && typeof updateResults === 'function') {
    try {
      const r = sc.results;
      if (r && r.stats && r.labels) {
        updateResults(r.labels, r.stats, r.boardA || [], r.boardB || []);
      }
    } catch (e) {
      console.warn('Failed to restore saved scenario results', e);
    }
  }
}

let _scCache = {};
let _scLoaded = false;

function scenOpenDB(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open('dbbp_db_v1', 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains('autosaves')){
        const s = db.createObjectStore('autosaves', { keyPath:'t' });
        s.createIndex('t','t');
      }
      if(!db.objectStoreNames.contains('scenarios')){
        db.createObjectStore('scenarios', { keyPath:'name' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function scenLoadCache(){
  try{
    const db = await scenOpenDB();
    const arr = await new Promise((resolve, reject)=>{
      const tx = db.transaction('scenarios','readonly');
      const st = tx.objectStore('scenarios');
      const req = st.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
    _scCache = {};
    arr.forEach(s => { if(s && s.name) _scCache[s.name] = s.data; });
    _scLoaded = true;
    return _scCache;
  }catch(e){
    console.warn('scenario cache load failed', e);
    _scCache = {}; _scLoaded = true;
    return _scCache;
  }
}

function listScenarios(){
  return _scCache; // sync accessor
}

async function saveScenario(name){
  if(!name) return;
  if(!_scLoaded) await scenLoadCache();
  const data = readScenarioState();
  _scCache[name] = data;

  const db = await scenOpenDB();
  await new Promise((resolve, reject)=>{
    const tx = db.transaction('scenarios','readwrite');
    tx.objectStore('scenarios').put({ name, data });
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
  populateScenarioList();
}

async function deleteScenario(name){
  if(!name) return;
  if(!_scLoaded) await scenLoadCache();
  delete _scCache[name];

  const db = await scenOpenDB();
  await new Promise((resolve, reject)=>{
    const tx = db.transaction('scenarios','readwrite');
    tx.objectStore('scenarios').delete(name);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
  populateScenarioList();
}

async function populateScenarioList(){
  if(!_scLoaded) await scenLoadCache();
  const sel=document.getElementById('scenarioList');
  const del=document.getElementById('deleteScenario');
  if(!sel) return;
  const names=Object.keys(_scCache).sort();
  sel.innerHTML='<option value="">Loadâ€¦</option>'+names.map(n=>`<option value="${n}">${n}</option>`).join('');
  if(del) del.disabled = !sel.value;
}

async function exportScenarios(){
  if(!_scLoaded) await scenLoadCache();
  const all = listScenarios();
  const blob=new Blob([JSON.stringify(all,null,2)],{type:'application/json'});
  const a=document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'dbbp_scenarios.json';
  document.body.appendChild(a); a.click(); a.remove();
}

async function importScenarios(file){
  const reader=new FileReader();
  reader.onload = async ()=>{
    try{
      const obj=JSON.parse(reader.result);
      if(!_scLoaded) await scenLoadCache();
      const db = await scenOpenDB();
      const tx = db.transaction('scenarios','readwrite');
      const st = tx.objectStore('scenarios');
      Object.entries(obj||{}).forEach(([name,data])=>{
        _scCache[name]=data;
        st.put({name, data});
      });
      tx.oncomplete = () => populateScenarioList();
    }catch(e){ alert('Import failed: '+e.message); }
  };
  reader.readAsText(file);
}

// Hook up scenario controls
if(document.getElementById('saveScenario')) document.getElementById('saveScenario').addEventListener('click', async ()=>{
  const name=(document.getElementById('scenarioName')?.value || '').trim();
  if(!name) { alert('Please enter a scenario name.'); return; }
  await saveScenario(name);
});
if(document.getElementById('scenarioList')) document.getElementById('scenarioList').addEventListener('change', async (e)=>{
  const v=e.target.value;
  const del=document.getElementById('deleteScenario');
  if(del) del.disabled = !v;
  if(v){ if(!_scLoaded) await scenLoadCache(); applyScenario(_scCache[v]); }
});
if(document.getElementById('deleteScenario')) document.getElementById('deleteScenario').addEventListener('click', async ()=>{
  const sel=document.getElementById('scenarioList');
  if(sel && sel.value){ if(confirm('Delete scenario "'+sel.value+'"?')) await deleteScenario(sel.value); }
});
if(document.getElementById('exportScenarios')) document.getElementById('exportScenarios').addEventListener('click', exportScenarios);
if(document.getElementById('importFile')) document.getElementById('importFile').addEventListener('change', (e)=>{
  const f=e.target.files && e.target.files[0]; if(f) importScenarios(f);
});

// populate list on load
document.addEventListener('DOMContentLoaded', ()=>{ populateScenarioList(); });


document.addEventListener('DOMContentLoaded', ()=>{
  // Card mode radio hooks
  const r4 = document.getElementById('cardMode4');
  const r5 = document.getElementById('cardMode5');
  const r6 = document.getElementById('cardMode6');
  if(r4) r4.addEventListener('change', ()=> setCardMode(4));
  if(r5) r5.addEventListener('change', ()=> setCardMode(5));
  if(r6) r6.addEventListener('change', ()=> setCardMode(6));

  // initialize
  initNumPlayersControl();
  setCardMode(4);

  // ğŸ”€ Single-board toggle
  const singleToggle = document.getElementById('singleBoardToggle');
  if (singleToggle) {
    // This controls how the *next* simulation will be run.
    SINGLE_BOARD_MODE = !!singleToggle.checked;

    singleToggle.addEventListener('change', () => {
      // Only affect future runs; existing results stay pinned to the mode
      // they were computed with (RESULTS_SINGLE_BOARD).
      SINGLE_BOARD_MODE = !!singleToggle.checked;
    });
  }

  // (removed legacy localStorage clearing on load â€” IndexedDB now used)
});
// ---------- Results renderer ----------
  
  // ---------- Results renderer ----------
function updateResults(labels, stats, boardA, boardB) {
  // cache for re-renders (sort/filter/reveal)
  _lastLabels  = labels;
  _lastStats   = stats;
  _lastBoardA  = boardA;
  _lastBoardB  = boardB;

  const resultsBody = document.querySelector('#resultsTable tbody');
  if (!resultsBody) return;

  // Given a board, a parsed exact hand, and that seat's wildcard hint,
  // decide whether a 5-card flush (and therefore straight flush) is even
  // possible under PLO (exactly 2 from hand, 3 from board).
  function canFlushOnBoard(board, parsedHand, hint) {
    // Only enforce an "impossible flush" filter when the board is fully specified.
    // For partial boards (flop / turn with unknown future cards), we must assume
    // that additional suited cards *can* arrive, so we never zero out Flush/Straight
    // Flush in those cases.
    if (!board || board.length < 5 || !hint) return true; // be conservative unless we know all 5 cards

    const boardSuitCounts = { c: 0, d: 0, h: 0, s: 0 };
    board.forEach(card => {
      if (typeof card === 'string' && card.length === 2) {
        const s = card[1].toLowerCase();
        if (boardSuitCounts[s] != null) boardSuitCounts[s]++;
      }
    });

    const handExactCounts = { c: 0, d: 0, h: 0, s: 0 };
    (parsedHand || []).forEach(card => {
      if (typeof card === 'string' && card.length === 2) {
        const s = card[1].toLowerCase();
        if (handExactCounts[s] != null) handExactCounts[s]++;
      }
    });

    const suitWildCounts = { c: 0, d: 0, h: 0, s: 0 };
    const suitWilds = (hint && Array.isArray(hint.suitWilds)) ? hint.suitWilds : [];
    suitWilds.forEach(s => {
      const low = String(s).toLowerCase();
      if (suitWildCounts[low] != null) suitWildCounts[low]++;
    });

    const anyWilds = (hint && typeof hint.anyWilds === 'number') ? hint.anyWilds : 0;

    // Check each suit: need >=3 on board, >=2 available from hand,
    // and >=5 total between board+hand to even *have* a flush.
    for (const suit of ['c', 'd', 'h', 's']) {
      const boardSuit = boardSuitCounts[suit];
      const handCap   = handExactCounts[suit] + suitWildCounts[suit] + anyWilds;
      if (boardSuit >= 3 && handCap >= 2 && (boardSuit + handCap) >= 5) {
        return true;
      }
    }

    return false;
  }

  // --- Board header ---
  const boardsHTML = (arr) =>
    arr && arr.length
      ? arr.map(renderCardHTML).join('')
      : '<span style="color:#9fb3c8">(random)</span>';

  const boardsHost = document.getElementById('resultsBoards');
  if (boardsHost) {
    boardsHost.innerHTML = `
      <div class="boards-inner">
        <div style="margin-bottom:10px"><strong>Board A:</strong> ${boardsHTML(boardA || [])}</div>
        <div><strong>Board B:</strong> ${
          SINGLE_BOARD_MODE
            ? ((boardB && boardB.length)
                ? boardsHTML(boardB || [])
                : '<span style="color:#9fb3c8">(n/a)</span>')
            : boardsHTML(boardB || [])
        }</div>
      </div>`;
  }

  // --- Global board-only winning-hand summary ---
  const labelsMap = ['High','1P','2P','Trips','Set','Str','Flush','FH','Quads','Str Flush'];

  function renderSummary(arr) {
    const total = (arr || []).reduce((a,b)=>a+b,0) || 1;
    return (arr || [])
      .map((v,i)=>({v,i}))
      .filter(x=>x.v>0)
      .sort((a,b)=>b.v-a.v)
      .map(x=>`<span style="display:inline-block;margin:2px 6px 2px 0;padding:2px 8px;border:1px solid var(--border);border-radius:999px;">${labelsMap[x.i]}: ${(x.v/total*100).toFixed(1)}%</span>`)
      .join('');
  }

  const sumEl = document.getElementById('winHandsSummary');
  if (sumEl && _lastStats && _lastStats.winClassA && _lastStats.winClassB) {
        const semSingle = (typeof RESULTS_SINGLE_BOARD !== 'undefined') ? !!RESULTS_SINGLE_BOARD : !!SINGLE_BOARD_MODE;
    let sumHTML = `
      <div style="margin:8px"><strong>Likely winning Hand Classes:</strong></div>
      <div style="margin:8px"><strong>${semSingle ? 'Single board' : 'A'}</strong> â†’ ${renderSummary(_lastStats.winClassA)}</div>
    `;
    if (!semSingle) {
      sumHTML += `
      <div style="margin:8px" class="likely-b-summary"><strong>B</strong> â†’ ${renderSummary(_lastStats.winClassB)}</div>
      `;
    }
    sumEl.innerHTML = sumHTML;
  }

  // --- Per-player â€œlikely handâ€ summary (conditional on that seat actually winning) ---
  // `totalWinsOrWeight` should be the total winning weight for this seat on that board
  // (e.g. winsA[i] or winsB[i]). If it's 0, we fall back to using raw trial count.
  function topHandsAbsolute(dist, trials) {
    const denom = (trials > 0 ? trials : 1);
    const arr = (dist || [])
      .map((v,i)=>({ i, p: v / denom }))
      .filter(x => x.p > 0)
      .sort((a,b)=> b.p - a.p)
      .slice(0,2);
    return arr.map(x => `${labelsMap[x.i]} ${(x.p*100).toFixed(1)}%`).join(' Â· ');
  }

  // --- Prepare table rows ---
  resultsBody.innerHTML = '';

  const {
    winsA,
    winsB,
    chops,
    scoops,
    quarters,
    trials,
    winClassAByP,
    winClassBByP
  } = stats;

  const rows = [];

  const semSingle = (typeof RESULTS_SINGLE_BOARD !== 'undefined')
    ? !!RESULTS_SINGLE_BOARD
    : !!SINGLE_BOARD_MODE;

  // Keep CSS in sync with the semantics of the current results.
  if (document && document.body) {
    document.body.classList.toggle('single-board-mode', semSingle);
  }

  for (let i = 0; i < labels.length; i++) {
    const aVal       = winsA[i]   / trials;
    const bVal       = winsB[i]   / trials;
    const totalEq    = semSingle
      ? (winsA[i] / trials)
      : ((winsA[i] + winsB[i]) / trials / 2);
    const chopPct    = chops[i]   / trials;
    const scoopPct   = scoops[i]  / trials;
    const quarterPct = quarters[i]/ trials;

    // Bucket row color
    let bucketClass = '';
    if      (totalEq >= 0.40) bucketClass = 'bucket-top';
    else if (totalEq >= 0.25) bucketClass = 'bucket-strong';
    else if (totalEq >= 0.15) bucketClass = 'bucket-medium';
    else if (totalEq >= 0.05) bucketClass = 'bucket-marginal';
    else                      bucketClass = 'bucket-weak';

    // --- Map player index -> actual seat index ---
    // labels[i] is like "Seat 8" even if itâ€™s the first non-empty row.
    const labelText = labels[i] || `Seat ${i+1}`;
    let seatIdx = i;
    const m = labelText.match(/(\d+)/);
    if (m) {
      const num = parseInt(m[1], 10);
      if (!Number.isNaN(num) && num >= 1 && num <= seatInputs.length) {
        seatIdx = num - 1;
      }
    }

    // --- Get the correct raw hand string for that seat (live or autosave view) ---
    let rawHand = '';
    if (_handsOverrideForRender && Array.isArray(_handsOverrideForRender)) {
      rawHand = _handsOverrideForRender[seatIdx] || '';
    } else if (seatInputs[seatIdx]) {
      rawHand = seatInputs[seatIdx].value || '';
    }

    const parsedHand   = parseHand(rawHand);
    const tokensForRow = parseTokensWithWildcards(rawHand, CARDS_PER_HAND);

    // Sort display tokens A â†’ 2 â†’ X (X always last)
    tokensForRow.sort((a, b) => {
      const ra = (a.rank && a.rank !== 'X') ? RANK_VAL[a.rank] : -100;
      const rb = (b.rank && b.rank !== 'X') ? RANK_VAL[b.rank] : -100;

      if (ra !== rb) return rb - ra;

      // Push fully unknown wildcards to the very end
      if (a.kind === 'anyWild' && b.kind !== 'anyWild') return 1;
      if (b.kind === 'anyWild' && a.kind !== 'anyWild') return -1;

      return 0;
    });

    const baseHandHTML = tokensToHTML(tokensForRow);

    // --- Range-mode labelling (buckets) ---
    let buckets = [];
    if (typeof getBucketsForSeat === 'function') {
      buckets = getBucketsForSeat(seatIdx) || [];
    }

    let handHTML = baseHandHTML;
    if (RANGE_MODE && buckets.length > 0) {
      const rangeText  = 'Range: ' + buckets.join(', ');
      const rangeHTML  = `<span class="range-label">${rangeText}</span>`;
      handHTML = baseHandHTML ? (baseHandHTML + rangeHTML) : rangeHTML;
    }

    // --- Per-player likely-hand distributions (with AAAA/KKKK fix) ---
    let distA = winClassAByP[i] || new Array(10).fill(0);
    let distB = winClassBByP[i] || new Array(10).fill(0);

    if (
      typeof CARDS_PER_HAND !== 'undefined' &&
      CARDS_PER_HAND === 4 &&
      parsedHand &&
      parsedHand.length === 4
    ) {
      const ranks = parsedHand.map(c => c[0]);
      if (ranks.every(r => r === ranks[0])) {
        // Copy before mutating
        distA = distA.slice();
        distB = distB.slice();
        // Pocket 4-of-a-kind cannot â€œmakeâ€ Trips / Set / Quads on its own
        distA[3] = 0; // Trips
        distA[4] = 0; // Set
        distA[8] = 0; // Quads
        distB[3] = 0;
        distB[4] = 0;
        distB[8] = 0;
      }
    }

    // Further sanity-check for PLO with wildcards:
    // If this seat cannot ever have 5 cards of the same suit using exactly 2
    // from hand + 3 from board, then Flush / Straight Flush should both be 0.
    let hintForSeat = null;
    if (typeof buildHandHintFromRaw === 'function') {
      hintForSeat = buildHandHintFromRaw(rawHand, CARDS_PER_HAND);
    }

    if (hintForSeat) {
      const canFlushA = canFlushOnBoard(boardA, parsedHand, hintForSeat);
      const canFlushB = canFlushOnBoard(boardB, parsedHand, hintForSeat);

      // winClass indices: 6 = Flush, 9 = Straight Flush
      if (!canFlushA) {
        distA = distA.slice();
        distA[6] = 0;
        distA[9] = 0;
      }
      if (!canFlushB) {
        distB = distB.slice();
        distB[6] = 0;
        distB[9] = 0;
      }
    }

    rows.push({
      idx: i,                // player index (for internal mapping)
      seatIdx,               // real seat index 0â€“8
      seatLabel: labelText,  // e.g. "Seat 8"
      aVal,
      bVal,
      totalEq,
      chopPct,
      scoopPct,
      quarterPct,
      bucketClass,
      handHTML,
      // Use *unconditional* equity contributions on each board:
      // these percentages are "share of total board equity by hand class"
      // and thus do not need to sum to 100%.
      likelyA: topHandsAbsolute(distA, trials),
      likelyB: topHandsAbsolute(distB, trials)
    });
  }

  // --- Sort by equity if requested ---
  if (typeof sortByEquityEl === 'function' && sortByEquityEl() && sortByEquityEl().checked) {
    rows.sort((r1, r2) => r2.totalEq - r1.totalEq);
  }

  // --- Filter by bucket if needed ---
  const bf = typeof bucketFilterEl === 'function' && bucketFilterEl()
    ? bucketFilterEl().value
    : 'all';

  // --- Render (Case C / mixed: rank index + seat label) ---
  const QUIZ = typeof QUIZ_ACTIVE !== 'undefined' ? QUIZ_ACTIVE : false;
  const QUIZ_HIDE = typeof QUIZ_REVEALED !== 'undefined' ? !QUIZ_REVEALED : false;

  rows.forEach((r, k) => {
    if (bf !== 'all' && r.bucketClass !== bf) return;

    const tr = document.createElement('tr');
    tr.classList.add(r.bucketClass);

    const aPct       = (r.aVal       * 100).toFixed(2) + '%';
    const bPct       = (r.bVal       * 100).toFixed(2) + '%';
    const eqPct      = (r.totalEq    * 100).toFixed(2) + '%';
    const scoopPct   = (r.scoopPct   * 100).toFixed(2) + '%';
    const quarterPct = (r.quarterPct * 100).toFixed(2) + '%';

    const mask = QUIZ && QUIZ_HIDE;

   // Display ONLY the real seat number in the "#" column
const seatCellHTML = `${r.seatIdx + 1}`;


   tr.innerHTML = `
  <td>${r.seatIdx + 1}</td>
  <td>${r.handHTML || ''}</td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : aPct}</td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : bPct}</td>
  <td class="${mask?'masked hidden-answer':''}"><span class="good">${mask ? 'â€”' : eqPct}</span></td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : (r.likelyA || '-')}</td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : (r.likelyB || '-')}</td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : scoopPct}</td>
  <td class="${mask?'masked hidden-answer':''}">${mask ? 'â€”' : (r.quarterPct * 100).toFixed(2) + '%'}</td>
  <td class="col-chop ${mask?'masked hidden-answer':''}">${mask ? 'â€”' : (r.chopPct * 100).toFixed(2) + '%'}</td>
`;

    resultsBody.appendChild(tr);
  });

}


  // ---------- Run / Cancel ----------
  function disableUI(dis) {
    document.getElementById('runBtn').disabled=dis;
    document.getElementById('resetBtn').disabled=dis;
    document.getElementById('trials').disabled=dis;
    if(document.getElementById('omniscientToggle')) omniscientToggle.disabled=dis;
    document.getElementById('randEmptySeats').disabled=dis;
    document.getElementById('randAllSeats').disabled=dis;
    const sbToggle = document.getElementById('singleBoardToggle');
    if (sbToggle) sbToggle.disabled = dis;

    ['A','B'].forEach(p=>{
      ['rand'+p,'clear'+p,'rand'+p+'Flop','rand'+p+'Turn','rand'+p+'River'].forEach(id=>{
        const el=document.getElementById(id);
        if(el) el.disabled=dis;
      
  });
    });
    seatInputs.forEach(i=> i.disabled=dis);
    boardSlots.forEach(i=> i.disabled=dis);
    cancelBtn.disabled = !dis; // enable cancel when running
  }

  

function buildHandHintFromRaw(raw, handSize){
  const hint = { rankWilds: [], suitWilds: [], anyWilds: 0, notRankPairs: [], notSuitPairs: [], notRankZero: [] };
  if (!raw) return hint;

  const tokens = (typeof parseTokensWithWildcards === 'function')
    ? parseTokensWithWildcards(raw, 32)
    : [];

  // Parse NOT tokens
  for (const t of tokens){
    if (!t || t.kind !== 'not' || !t.code) continue;
    const c = String(t.code).toUpperCase();
    // !AA style (no pair of A)
    if (c.length === 3 && c[0] === '!' && c[1] === c[2] && RANKS.includes(c[1])) {
      hint.notRankPairs.push(c[1]);
      continue;
    }
    // !SS style (no 2 of suit)
    if (c.length === 3 && c[0] === '!' && c[1] === c[2] && SUITS.includes(c[1])) {
      hint.notSuitPairs.push(c[1]);
      continue;
    }
    // !KX style (no rank at all)
    if (c.length === 3 && c[0] === '!' && RANKS.includes(c[1]) && c[2] === 'X') {
      hint.notRankZero.push(c[1]);
      continue;
    }
  }

  // Parse wildcard constraints from card tokens (ignore NOT chips)
  const handSizeN = (typeof handSize === 'number' && handSize > 0) ? handSize : CARDS_PER_HAND;

  for (const tok of tokens){
    if (!tok || tok.kind === 'not') continue;

    if (tok.kind === 'rankWild' && tok.rank){
      hint.rankWilds.push(tok.rank);
    } else if (tok.kind === 'suitWild' && tok.suit){
      hint.suitWilds.push(tok.suit);
    } else if (tok.kind === 'anyWild'){
      hint.anyWilds++;
    } else if (tok.kind === 'exact'){
      // exact doesn't add constraints here
    } else {
      // unknown token: treat as fully unconstrained wildcard
      hint.anyWilds++;
    }
  }

  // If user entered fewer than handSize tokens total (excluding NOT),
  // fill remaining slots as unconstrained wildcards
  const enteredCardLike = tokens.filter(t => t && t.kind !== 'not').length;
  const missing = Math.max(0, handSizeN - enteredCardLike);
  if (missing > 0) hint.anyWilds += missing;

  return hint;
}


// Scan a raw seat string for duplicate concrete cards (2s, Ah, etc.),
// independent of how parseHand() or wildcards behave.
function findConcreteDuplicatesInRaw(raw) {
  if (!raw) return [];
  const t = String(raw).toUpperCase();
  // Match any rank-suit pair like "2S", "TD", "AH" etc.
  const re = /([2-9TJQKA][CDHS])/g;
  const seen = new Set();
  const dupes = new Set();
  let m;
  while ((m = re.exec(t)) !== null) {
    const card = m[1];
    if (seen.has(card)) {
      dupes.add(card);
    } else {
      seen.add(card);
    }
  }
  return Array.from(dupes);
}

function readHands(){
  const hands     = [];
  const labels    = [];
  const errors    = [];
  const handHints = [];

  // Respect current player cap for this mode
  const maxByMode = (typeof allowedSeatsFor === 'function')
    ? allowedSeatsFor(CARDS_PER_HAND)
    : seatInputs.length;
  const lim = Math.min(maxByMode, CURRENT_PLAYERS || maxByMode);

  // Pre-scan: how many active (enabled) seats actually have any user-entered text?
  const activeFilled = [];
  seatInputs.forEach((inp, idx) => {
    if (idx >= lim) return;
    if (inp.disabled) return;
    if (typeof inp.value === 'string' && inp.value.trim().length > 0) {
      activeFilled.push(idx);
    }
  });

  const autoWildcardMode = (activeFilled.length >= 1);

  seatInputs.forEach((inp, idx) => {
    if (idx >= lim) return;

    const rawOriginal = inp.value;
    const isDisabled = !!inp.disabled;

    // Ignore disabled seats entirely.
    if (isDisabled) return;

    // If exactly one seat has been entered and this seat is empty,
    // treat it as a full wildcard hand (all cards unknown) for this sim snapshot.
    if (autoWildcardMode && (!rawOriginal || !rawOriginal.trim().length)) {
      const wildcardHint = {
        rankWilds: [],
        suitWilds: [],
        anyWilds: CARDS_PER_HAND
      };
      hands.push([]);  // no concrete cards
      labels.push(`Seat ${idx+1}`);
      handHints.push(wildcardHint);
      return;
    }

    const raw = rawOriginal;

    // Hard validation: no duplicate concrete cards inside a single seat input.
    const rawDupes = findConcreteDuplicatesInRaw(raw);
    if (rawDupes.length) {
      errors.push(
        `Seat ${idx+1}: duplicate concrete cards in input: ` +
        rawDupes.map(x => `<code>${x}</code>`).join(' ')
      );
    }

    const h   = parseHand(raw);
    const hint = (typeof buildHandHintFromRaw === 'function')
      ? buildHandHintFromRaw(raw, CARDS_PER_HAND)
      : null;

    const hasExact = h && h.length > 0;
    const hasWildcards =
      hint &&
      (
        (Array.isArray(hint.rankWilds) && hint.rankWilds.length > 0) ||
        (Array.isArray(hint.suitWilds) && hint.suitWilds.length > 0) ||
        (typeof hint.anyWilds === 'number' && hint.anyWilds > 0)
      );

    // Completely empty seat: no exact cards, no wildcard constraints â†’ skip
    if (!hasExact && !hasWildcards) return;

    // Allow partial exact cards: 0..CARDS_PER_HAND, wildcards will fill the rest
    if (h.length > CARDS_PER_HAND) {
      errors.push(`Seat ${idx+1}: too many cards (max ${CARDS_PER_HAND})`);
      return;
    }

    hands.push(h);
    labels.push(`Seat ${idx+1}`);
    handHints.push(hint || { rankWilds: [], suitWilds: [], anyWilds: 0 });
  });

  // Duplicate detection across seats (on top of UI-level highlighting)
  const seen = new Set();
  for (const h of hands) {
    for (const c of h) {
      if (seen.has(c)) {
        errors.push(`Card ${c} appears more than once across seats`);
      }
      seen.add(c);
    }
  }

  return { hands, labels, errors, handHints };
}
function readBoards(){
  const A = [];
  const B = [];
  const used = new Set();

  // Board A is always active
  for (let i = 0; i < 5; i++) {
    const inpA = document.querySelector(`input[data-slot="A${i}"]`);
    const a = normalizeCard(inpA && inpA.value);
    if (a) {
      if (used.has(a)) return { error: `Duplicate card ${a} on boards` };
      A.push(a);
      used.add(a);
    }
  }

  // Board B is ignored entirely in single-board mode
  if (!SINGLE_BOARD_MODE) {
    for (let i = 0; i < 5; i++) {
      const inpB = document.querySelector(`input[data-slot="B${i}"]`);
      const b = normalizeCard(inpB && inpB.value);
      if (b) {
        if (used.has(b)) return { error: `Duplicate card ${b} on boards` };
        B.push(b);
        used.add(b);
      }
    }
  }

  return { A, B };
}


  
  
  function readHandsRange(){
    const hands=[], labels=[], errors=[], rangeMeta=[];
    for(let i=0;i<seatInputs.length;i++){
      const inp = seatInputs[i];
      const h = parseHand(inp.value);
      const buckets = (typeof getBucketsForSeat === 'function') ? getBucketsForSeat(i) : [];
      const hasExact = h.length>0;
      const hasBuckets = buckets.length>0;
      if(!hasExact && !hasBuckets) continue;
      if(hasExact && h.length!==CARDS_PER_HAND){
        errors.push(`Seat ${i+1}: needs ${CARDS_PER_HAND} cards or leave blank when using buckets`);
      }
      labels.push(`Seat ${i+1}`);
      hands.push(hasExact && h.length===CARDS_PER_HAND ? h : []);
      rangeMeta.push({ buckets, hasExact: hasExact && h.length===CARDS_PER_HAND });
    }
    return {hands,labels,errors,rangeMeta};
  }

async function runSim(){
  if (simWorkers.length) { killWorker(); }

  // Weâ€™re starting a fresh run â†’ weâ€™re looking at the current sim, not history
  _viewingHistoryIndex = null;


    let hands,labels,errors,rangeMeta,handHints;
    if (RANGE_MODE) {
      ({hands,labels,errors,rangeMeta} = readHandsRange());
    } else {
      ({hands,labels,errors,handHints} = readHands());
      rangeMeta = null;
    }
    const boards=readBoards();
    
    if(errors.length){ errorBox.classList.add('show'); errorBox.innerHTML='âš ï¸ '+errors.join('<br>'); return; }
    if(boards.error){ errorBox.classList.add('show'); errorBox.innerHTML='âš ï¸ '+boards.error; return; }
    if(hands.length<2){ errorBox.classList.add('show'); errorBox.innerHTML='âš ï¸ Enter at least two seats.'; return; }
    const typed=allTypedMap(); const dups=Object.keys(typed).filter(k=>typed[k]>1);
    if(dups.length){
    errorBox.classList.add('show');
    errorBox.innerHTML='ğŸš« Duplicate cards: '+dups.map(x=>`<code>${x}</code>`).join(' ');
    return;
  }

  errorBox.classList.remove('show');
  errorBox.innerHTML='';

  // ğŸ”’ Freeze the seat + mode snapshot for this run
  const seatsSnapshot = seatInputs.map(inp => inp.value);
  const modeSnapshot  = CARDS_PER_HAND;

  // Pin semantics (single vs double) for this run
  if (typeof RESULTS_SINGLE_BOARD === 'undefined') {
    window.RESULTS_SINGLE_BOARD = !!SINGLE_BOARD_MODE;
  } else {
    RESULTS_SINGLE_BOARD = !!SINGLE_BOARD_MODE;
  }

  const trials = Math.max(100, parseInt(document.getElementById('trials').value) | 0);

  // Auto-switch to V Exact in two cases:
//   (1) any wildcards (Ax / Xs / XX etc.),
//   (2) any seat with fewer than CARDS_PER_HAND typed (partial hand).
let hasWildcardsOrPartial = false;

if (!RANGE_MODE) {
  const hasPartial = Array.isArray(hands) && hands.some(h => h && h.length < CARDS_PER_HAND);

  let hasWildcard =
    Array.isArray(handHints) &&
    handHints.some(h =>
      h &&
      (
        (Array.isArray(h.rankWilds) && h.rankWilds.length > 0) ||
        (Array.isArray(h.suitWilds) && h.suitWilds.length > 0) ||
        (typeof h.anyWilds === 'number' && h.anyWilds > 0)
      )
    );

  // Fallback / safety net: look directly at the raw seat + board strings
  if (!hasWildcard) {
    const seatHasX = Array.isArray(seatInputs) && seatInputs.some(inp =>
      inp && typeof inp.value === 'string' && /x/i.test(inp.value)
    );
    const boardHasX = Array.isArray(boardSlots) && boardSlots.some(inp =>
      inp && typeof inp.value === 'string' && /x/i.test(inp.value)
    );
    if (seatHasX || boardHasX) {
      hasWildcard = true;
    }
  }

  hasWildcardsOrPartial = !!(hasPartial || hasWildcard);
}

if (hasWildcardsOrPartial && !isOmniscientMode()) {
  setOmniscientMode(true); // also updates the V Random / V Exact menu display
}

  const subjective = !isOmniscientMode();

      // --- QUICK deterministic path for full boards in omniscient mode ---
  const boardAFull = boards.A.length === 5;
  const boardBFull = boards.B.length === 5;
  const omniscient = isOmniscientMode();
  const anyPartialHand = hands.some(h => h.length < CARDS_PER_HAND);

  if (!RANGE_MODE && omniscient && !anyPartialHand && (boardAFull || boardBFull)) {
    // Pin semantics for this deterministic eval (single vs double board)
    if (typeof RESULTS_SINGLE_BOARD === 'undefined') {
      window.RESULTS_SINGLE_BOARD = !!SINGLE_BOARD_MODE;
    } else {
      RESULTS_SINGLE_BOARD = !!SINGLE_BOARD_MODE;
    }

    // use the existing worker logic but just once, to reuse its functions
    const handsCopy = hands.map(h => [...h]);
    const boardsCopy = { A: [...boards.A], B: [...boards.B] };

    // Build a small temporary worker for a single deterministic eval
    simWorkers = [buildWorker()];
    simWorkers[0].onmessage = (e)=>{
  if (e.data.type === 'done') {
    if (_viewingHistoryIndex === null) {
      updateResults(labels, e.data.stats, boardsCopy.A, boardsCopy.B);
    }
    autosaveNow(labels, e.data.stats, boardsCopy.A, boardsCopy.B);
    disableUI(false);
    enableClearButtons();
    killWorker();
  }
};
    disableUI(true);
    disableClearButtons();
    simWorkers[0].postMessage({
      type:'run',
      hands: handsCopy,
      handSize: CARDS_PER_HAND,
      fixedA: boardsCopy.A,
      fixedB: boardsCopy.B,
      trials: 1,                 // only one deterministic run
      subjective: false,
      progressEvery: 1,
      bucketCfg: BUCKET_CFG,
      rangeMode: RANGE_MODE,
      rangeMeta,
      singleBoardMode: SINGLE_BOARD_MODE,
      rngSeed: ((Date.now() ^ Math.floor(Math.random() * 0xFFFFFFFF)) >>> 0)
    });
    return; // âœ… stop here, skip full Monte Carlo
  }

    const nPlayers = labels.length;
    const totalUnits = trials * (subjective ? nPlayers : 1);
    bar.style.width='0%';
    progressLabel.textContent=`0 / ${totalUnits} (0%) â€¢ Remaining: ${totalUnits}`;
    // --- Pre-render hands & boards immediately so they are visible at t=0 ---
    (function initZeroResults(){
      const N = labels.length || 0;
      const zero = (n)=>Array.from({length:n}, ()=>0);
      const stats0 = {
        winsA: zero(N), winsB: zero(N),
        chops: zero(N), scoops: zero(N), quarters: zero(N),
        trials: 1,
        winClassA: zero(10), winClassB: zero(10),
        winClassAByP: Array.from({length:N}, ()=>zero(10)),
        winClassBByP: Array.from({length:N}, ()=>zero(10)),
      };
      updateResults(labels, stats0, boards.A, boards.B);
    })();


    // â”€â”€ Multi-worker Monte Carlo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Split trials evenly across all logical CPU cores (max 8 to avoid overhead).
    const numWorkers = Math.min(navigator.hardwareConcurrency || 4, 8);
    const baseTrials = Math.floor(trials / numWorkers);
    const remainder  = trials - baseTrials * numWorkers;
    const baseSeed   = ((Date.now() ^ Math.floor(Math.random() * 0xFFFFFFFF)) >>> 0);

    // Per-worker tracking
    const workerProgress = new Array(numWorkers).fill(0);
    const latestPartial  = new Array(numWorkers).fill(null);
    let   doneCount      = 0;

    function mergeStats(a, b) {
      return {
        trials:       a.trials + b.trials,
        winsA:        a.winsA.map((v, i) => v + b.winsA[i]),
        winsB:        a.winsB.map((v, i) => v + b.winsB[i]),
        chops:        a.chops.map((v, i) => v + b.chops[i]),
        scoops:       a.scoops.map((v, i) => v + b.scoops[i]),
        quarters:     a.quarters.map((v, i) => v + b.quarters[i]),
        winClassA:    a.winClassA.map((v, i) => v + b.winClassA[i]),
        winClassB:    a.winClassB.map((v, i) => v + b.winClassB[i]),
        winClassAByP: a.winClassAByP.map((row, i) => row.map((v, j) => v + b.winClassAByP[i][j])),
        winClassBByP: a.winClassBByP.map((row, i) => row.map((v, j) => v + b.winClassBByP[i][j])),
      };
    }

    function mergeLatest() {
      return latestPartial.reduce((acc, s) => s ? (acc ? mergeStats(acc, s) : s) : acc, null);
    }

    disableUI(true);
    disableClearButtons();

    // Build the first worker (this sets workerURL), then reuse the blob URL for the rest
    for (let wi = 0; wi < numWorkers; wi++) {
      const wTrials = baseTrials + (wi === numWorkers - 1 ? remainder : 0);
      // Each worker gets a unique seed so they explore independent RNG streams
      const wSeed   = ((baseSeed + wi * 0x9E3779B9) >>> 0);
      const step    = Math.max(1, Math.floor(wTrials * 0.01));
      const w       = wi === 0 ? buildWorker() : new Worker(workerURL);
      simWorkers.push(w);

      const idx = wi; // capture loop variable for closure
      w.onmessage = (e) => {
        const { type } = e.data;

        if (type === 'progress') {
          workerProgress[idx] = e.data.unitsDone | 0;
          const totalDone = workerProgress.reduce((a, b) => a + b, 0);
          const pct = totalUnits ? (totalDone / totalUnits * 100) : 0;
          bar.style.width = pct.toFixed(1) + '%';
          progressLabel.textContent =
            `${totalDone} / ${totalUnits} (${pct.toFixed(1)}%) â€¢ Remaining: ${Math.max(0, totalUnits - totalDone)}`;

        } else if (type === 'partial') {
          latestPartial[idx] = e.data.stats;
          if (_viewingHistoryIndex === null) {
            const merged = mergeLatest();
            if (merged) updateResults(labels, merged, boards.A, boards.B);
          }

        } else if (type === 'done') {
          latestPartial[idx] = e.data.stats;
          workerProgress[idx] = wTrials * (subjective ? nPlayers : 1);
          doneCount++;

          if (doneCount === numWorkers) {
            const merged = mergeLatest();
            bar.style.width = '100%';
            progressLabel.textContent = `${totalUnits} / ${totalUnits} (100%) â€¢ Remaining: 0`;
            if (_viewingHistoryIndex === null) updateResults(labels, merged, boards.A, boards.B);
            autosaveNow(labels, merged, boards.A, boards.B);
            disableUI(false);
            enableClearButtons();
            killWorker();
          } else if (_viewingHistoryIndex === null) {
            // Show merged results as each worker finishes even before all are done
            const merged = mergeLatest();
            if (merged) updateResults(labels, merged, boards.A, boards.B);
          }
        }
      };

      w.postMessage({
        type: 'run',
        hands,
        handHints,
        handSize: CARDS_PER_HAND,
        fixedA: boards.A,
        fixedB: boards.B,
        trials: wTrials,
        subjective,
        progressEvery: step,
        partialEvery:  step,
        rangeMode: RANGE_MODE,
        rangeMeta,
        bucketCfg: BUCKET_CFG,
        singleBoardMode: SINGLE_BOARD_MODE,
        rngSeed: wSeed
      });
    }

  }

  // Buttons
  document.getElementById('runBtn').addEventListener('click', runSim);
  document.getElementById('cancelBtn').addEventListener('click', ()=>{
    if(simWorkers.length){
      simWorkers.forEach(w => w.postMessage({type:'cancel'}));
      setTimeout(()=>{
        if(simWorkers.length){
          bar.style.opacity = 0.5;
          errorBox.classList.add('show');
          errorBox.innerHTML='â¹ï¸ Run canceled';
          disableUI(false);
          enableClearButtons();
          killWorker();
        }
      }, 250);
    }
  });
  document.getElementById('resetBtn').addEventListener('click', ()=>{
    seatInputs.forEach(i=> i.value='');
    boardSlots.forEach(i=> i.value='');

    // Clear all range bucket selections
    if (typeof bucketGroups !== 'undefined' && bucketGroups) {
      bucketGroups.forEach(grp => {
        if (!grp) return;
        grp.querySelectorAll('.bucketBtn.active').forEach(btn => {
          btn.classList.remove('active');
        });
      });
      if (typeof markBucketSeats === 'function') {
        markBucketSeats();
      }
    }

    winHandsSummary.innerHTML='';
    resultsBody.innerHTML='';
    document.getElementById('resultsBoards').innerHTML='';
    bar.style.width='0%';
    progressLabel.textContent='0 / 0 (0%) â€¢ Remaining: 0';
    errorBox.classList.remove('show'); errorBox.innerHTML='';
    highlightDuplicates();
  });

  // ---------- Self-tests (non-blocking) ----------
  (function selfTests(){
    const out=document.getElementById('selfTest');
    function log(msg){ out.innerHTML += (out.innerHTML? '<br>':'') + msg; }
    try{
      const runBtn=document.getElementById('runBtn');
      disableUI(true);
      console.assert(runBtn.disabled===true, 'runBtn should be disabled');
      disableUI(false);
      console.assert(runBtn.disabled===false, 'runBtn should be enabled');
      highlightDuplicates();

      // Worker compilation smoke test
      const w1=buildWorker();
      w1.terminate();
      log('');

      // Trips vs Set tests (deterministic):
      // Board: paired A A 7 8 9 (no full house). Single-seat runs.
      const boardAA789=['AS','AH','7D','8C','9C'];

      // Expect SET when hole is AA**
      const wSet=buildWorker();
      wSet.onmessage=(e)=>{
        if(e.data && e.data.type==='done'){
          const arr=e.data.stats.winClassA; // index 4 is Set bucket
          console.assert(arr[4]===1, 'Expected Set bucket increment');
          wSet.terminate();
          log('');
        }
      };
      wSet.postMessage({type:'run', hands:[["AD","AC","2D","3C"]], fixedA:boardAA789, fixedB:[], trials:1, subjective:false, progressEvery:1});

      // Expect TRIPS when hole has one Ace only
      const wTrips=buildWorker();
      wTrips.onmessage=(e)=>{
        if(e.data && e.data.type==='done'){
          const arr=e.data.stats.winClassA; // index 3 is Trips bucket
          console.assert(arr[3]===1, 'Expected Trips bucket increment');
          wTrips.terminate();
          log('');
        }
      };
      wTrips.postMessage({type:'run', hands:[["AD","KC","2D","3C"]], fixedA:boardAA789, fixedB:[], trials:1, subjective:false, progressEvery:1});

      // NEW: Enforce pocket-pair for Quads labeling
      // Case 1: Board A A K Q 7; Hand A K 2 3 (no pocket pair, no duplicate cards).
      // Only 3 aces exist (AS, AH, AD) so quads are impossible; best hand is
      // Full House: AD+KD (hand) + AS+AH+KC (board) = aces full of kings.
      const boardAAKQ7=['AS','AH','KC','QH','7D'];
      const wNoQuad=buildWorker();
      wNoQuad.onmessage=(e)=>{
        if(e.data && e.data.type==='done'){
          const arr=e.data.stats.winClassA; // 7 = Full House, 8 = Quads
          console.assert(arr[7]===1 && arr[8]===0, 'Expected Full House label, not Quads, when no pocket pair');
          wNoQuad.terminate();
          log('');
        }
      };
      wNoQuad.postMessage({type:'run', hands:[["AD","KD","2D","3C"]], fixedA:boardAAKQ7, fixedB:[], trials:1, subjective:false, progressEvery:1});

      // Case 2: Pocket pair makes Quads label allowed: Board A A 7 8 9; Hand A A X X â†’ Quads label (index 8)
      const wYesQuad=buildWorker();
      wYesQuad.onmessage=(e)=>{
        if(e.data && e.data.type==='done'){
          const arr=e.data.stats.winClassA;
          console.assert(arr[8]===1, 'Expected Quads label when pocket pair matches board pair');
          wYesQuad.terminate();
          log('');
        }
      };
      wYesQuad.postMessage({type:'run', hands:[["AD","AC","2D","3C"]], fixedA:boardAA789, fixedB:[], trials:1, subjective:false, progressEvery:1});

    }catch(e){ log('âœ— Self-tests failed: '+e.message); console.error(e); }
  })();

  // extra self-test: ensure per-player arrays exist
  (function(){
    try{
      const w=buildWorker();
      w.onmessage=(e)=>{
        if(e.data && e.data.type==='done'){
          const s=e.data.stats;
          console.assert(Array.isArray(s.winClassAByP) && Array.isArray(s.winClassBByP), 'Per-player likely-hand arrays present');
          w.terminate();
          document.getElementById('selfTest').innerHTML += '<br>';
        }
      };
      w.postMessage({type:'run', hands:[["AS","KS","QD","JC"],["2S","3S","4D","5C"]], fixedA:[], fixedB:[], trials:1, subjective:false, progressEvery:1});
    }catch(e){ document.getElementById('selfTest').innerHTML += '<br>âœ— Per-player arrays test failed: '+e.message; }
  })();

  // init
  highlightDuplicates();


// ---- Merged from earlier script ----
// ----- live cardchip rendering for seats & boards -----
(function(){
  // ensure each seat has a chip container
  seatInputs.forEach((inp, i) => {
    const host = inp.parentElement;
    if (!host.querySelector('.chipout')) {
      const div = document.createElement('div');
      div.className = 'chipout';
      host.appendChild(div);
    }
  });

  // ensure each board input (.cardin input) has a chip container
  document.querySelectorAll('.cardin').forEach(c => {
    if (!c.querySelector('.chipout')) {
      const div = document.createElement('div');
      div.className = 'chipout';
      c.appendChild(div);
    }
  });

  // render helpers
  function applyAutoXxToOtherSeats(){
    // Respect current player cap for this mode
    const maxByMode = (typeof allowedSeatsFor === 'function')
      ? allowedSeatsFor(CARDS_PER_HAND)
      : seatInputs.length;
    const lim = Math.min(maxByMode, CURRENT_PLAYERS || maxByMode);

    // First pass: see if there is at least one active, filled seat
    let anyFilled = false;
    seatInputs.forEach((inp, idx) => {
      if (idx >= lim) return;
      if (inp.disabled) return;
      if (typeof inp.value === 'string' && inp.value.trim().length > 0) {
        anyFilled = true;
      }
    });

    // Second pass: for active seats under the cap,
    // either clear or decorate empties with Xx based on anyFilled.
    seatInputs.forEach((inp, idx) => {
      if (idx >= lim) return;
      if (inp.disabled) return;
      if (!inp.parentElement) return;

      const host = inp.parentElement;
      const out  = host.querySelector('.chipout');
      if (!out) return;

      const isEmpty = !inp.value || !inp.value.trim().length;

      if (!anyFilled) {
        // No anchor seat â†’ empties should be visually blank and have no text.
        if (isEmpty) {
          out.innerHTML = '';
          inp.value = '';
        }
        return;
      }

      // We have at least one filled seat.
      // Any truly empty, active seat under the player cap becomes a full Xx hand,
      // both in the text field (so autosave/scenarios remember it) and visually.
      //
      // BUT: if the user explicitly cleared an auto-filled Xx seat, respect that and keep it blank.
      if (isEmpty) {
        if (inp.dataset && inp.dataset.userCleared === '1') {
          out.innerHTML = '';
          inp.value = '';
          return;
        }
        const parts = [];
        for (let k = 0; k < CARDS_PER_HAND; k++) {
          parts.push('Xx');
        }
        inp.value = parts.join(' ');
        if (inp.dataset) inp.dataset.autofilled = '1';

        const wilds = Array.from(
          { length: CARDS_PER_HAND },
          () => ({ kind: 'anyWild', code: 'XX' })
        );
        out.innerHTML = tokensToHTML(wilds);
      }
    });
  }
  function updateSeatChip(i){
    const inp = seatInputs[i];
    const out = inp.parentElement.querySelector('.chipout');
    if (!out) return;
    const tokens = parseTokensWithWildcards(inp.value, CARDS_PER_HAND);

    // Sort tokens visually A â†’ 2 â†’ X
    tokens.sort((a, b) => {
      const ra = (a.rank && RANK_VAL[a.rank]) || -1;
      const rb = (b.rank && RANK_VAL[b.rank]) || -1;

      // Exact & rankWild first by rank
      if (ra !== rb) return rb - ra;

      // Push anyWild and suitWild to the end
      if (a.kind === 'anyWild' && b.kind !== 'anyWild') return 1;
      if (b.kind === 'anyWild' && a.kind !== 'anyWild') return -1;

      return 0;
    });

    out.innerHTML = tokens.length ? tokensToHTML(tokens) : '';

    // After updating this seat, optionally decorate other seats with Xx if only one hand is entered
    applyAutoXxToOtherSeats();
  }
  function updateBoardChip(inp){
    const parent = inp.parentElement;
    let out = parent.querySelector('.chipout');
    if (!out){
      out = document.createElement('div');
      out.className = 'chipout';
      parent.appendChild(out);
    }
    const c = normalizeCard(inp.value);
    out.innerHTML = c ? renderCardHTML(c) : '';
  }
  function updateAllChips(){
    seatInputs.forEach((_, i)=> updateSeatChip(i));
    boardSlots.forEach(inp => updateBoardChip(inp));
  }

  // wire up input listeners (live)
    // wire up input listeners (live)
  seatInputs.forEach(inp => inp.addEventListener('input', (ev) => {
    // If the user manually clears a seat, don't auto-regenerate Xx Xx Xx Xx.
    if (ev && ev.isTrusted && ev.target && ev.target.dataset) {
      const v = (ev.target.value || '').trim();
      if (v === '') {
        ev.target.dataset.userCleared = '1';
        delete ev.target.dataset.autofilled;
      } else {
        delete ev.target.dataset.userCleared;
        delete ev.target.dataset.autofilled;
      }
    }
    updateAllChips();
  }));

  // Board A / Board B: auto-advance cursor to the next slot after 2 chars
  boardSlots.forEach((inp, idx) => {
    inp.addEventListener('input', (ev) => {
      // keep existing chip rendering
      updateBoardChip(inp);

      // Only auto-advance for real user typing, not programmatic .dispatchEvent()
      if (!ev.isTrusted) return;

      const val = (inp.value || '').trim();
      const maxLen = inp.maxLength || 2;

      // When the user has finished typing a full card (2 chars), jump
      if (val.length >= maxLen) {
        let next = null;

        // Look for the next board input in DOM order (A0-A4, then B0-B4)
        for (let j = idx + 1; j < boardSlots.length; j++) {
          const candidate = boardSlots[j];
          if (!candidate || candidate.disabled) continue;

          // Prefer an actually "available" (not already full) field
          const cVal = (candidate.value || '').trim();
          if (cVal.length < (candidate.maxLength || 2)) {
            next = candidate;
            break;
          }
        }

        if (next) {
          next.focus();
          // select existing contents so you can immediately overwrite if needed
          next.select();
        }
      }
    });
  });

  // make all existing calls to highlightDuplicates() also refresh chips
  const _highlightDuplicates = highlightDuplicates;
  window.highlightDuplicates = function(){
    _highlightDuplicates();
    updateAllChips();
  };

  // initial paint
  updateAllChips();
})();


// ---- Merged from earlier script ----
document.addEventListener('DOMContentLoaded', function () {
  try {
    var resultsFilters = document.getElementById('resultsFilters');
    var studyControls = document.getElementById('studyControls');
    if (resultsFilters && studyControls) {
      var sortInput = document.getElementById('sortByEquity');
      var bucketSelect = document.getElementById('bucketFilter');

      // Move entire label wrappers if present
      if (sortInput && sortInput.closest('label')) {
        resultsFilters.appendChild(sortInput.closest('label'));
      }
      if (bucketSelect && bucketSelect.closest('label')) {
        resultsFilters.appendChild(bucketSelect.closest('label'));
      }
    }
  } catch (e) {
    console.error('Error relocating results controls:', e);
  }
});


// ---- Merged from earlier script ----
/* ===== AUTOSAVE HISTORY (Prev/Next in Results) â€” IndexedDB =====
   Replaces localStorage-based history with IndexedDB.
   Keeps a synchronous in-memory cache so the rest of the app
   (renderAutosaveAt / refreshAutoNav) can stay mostly unchanged.
*/
const AUTO_MAX = 2500;

// IndexedDB setup
const DB_NAME = 'dbbp_db_v1';
const DB_VER  = 1;
const STORE_AUTOS = 'autosaves';
const STORE_SCEN  = 'scenarios';

let _autoCache = [];
let _autoCacheLoaded = false;
let _autoIndex = -1;
// null = viewing current/live sim; number = index into autosaves history
let _viewingHistoryIndex = null;
let _handsOverrideForRender = null;

function idbOpen(){
  return new Promise((resolve, reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE_AUTOS)){
        const s = db.createObjectStore(STORE_AUTOS, { keyPath: 't' }); // t = timestamp
        s.createIndex('t', 't');
      }
      if(!db.objectStoreNames.contains(STORE_SCEN)){
        db.createObjectStore(STORE_SCEN, { keyPath: 'name' });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function auto_loadCache(){
  try{
    const db = await idbOpen();
    const arr = await new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE_AUTOS, 'readonly');
      const st = tx.objectStore(STORE_AUTOS);
      const req = st.getAll();
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
    arr.sort((a,b)=>a.t-b.t);
    _autoCache = arr;
    _autoCacheLoaded = true;
    return arr;
  }catch(e){
    console.warn('autosave cache load failed', e);
    _autoCache = [];
    _autoCacheLoaded = true;
    return [];
  }
}

function auto_list(){
  // synchronous accessor for legacy callers
  return _autoCache;
}

async function auto_addSnap(snap){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE_AUTOS, 'readwrite');
    const st = tx.objectStore(STORE_AUTOS);
    st.put(snap);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function auto_deleteByT(t){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE_AUTOS, 'readwrite');
    tx.objectStore(STORE_AUTOS).delete(t);
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

async function auto_clearAll(){
  const db = await idbOpen();
  return new Promise((resolve, reject)=>{
    const tx = db.transaction(STORE_AUTOS, 'readwrite');
    tx.objectStore(STORE_AUTOS).clear();
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error);
  });
}

/**
 * Autosave the current run.
 * - seatsOverride: frozen seat strings from run start (optional)
 * - modeOverride : frozen CARDS_PER_HAND from run start (optional)
 */
async function autosaveNow(labels, stats, A, B, seatsOverride, modeOverride){
  try {
    if(!_autoCacheLoaded) await auto_loadCache();

    const seatsText = Array.isArray(seatsOverride)
      ? seatsOverride.slice()
      : seatInputs.map(inp => inp.value);
    const activeSeats = seatsText.filter(s => s && s.trim()).length;

    const mode = (typeof modeOverride === 'number')
      ? modeOverride
      : CARDS_PER_HAND;

    const rangeModeSnap = !!RANGE_MODE;
    const bucketSnap = (typeof serializeSeatBuckets === 'function')
      ? serializeSeatBuckets()
      : null;
    const viewModeExact = typeof isOmniscientMode === 'function'
      ? !!isOmniscientMode()
      : false;
    const singleBoardModeSnap = !!SINGLE_BOARD_MODE;

    const snap = {
      t: Date.now(),
      mode,
      players: activeSeats,
      seats: seatsText,
      A: [...A],
      B: [...B],
      labels: [...labels],
      stats,
      rangeMode: rangeModeSnap,
      seatBuckets: bucketSnap,
      viewModeExact,
      singleBoardMode: singleBoardModeSnap
    };

    await auto_addSnap(snap);
    _autoCache.push(snap);
    _autoCache.sort((a,b)=>a.t-b.t);

    while(_autoCache.length > AUTO_MAX){
      const oldest = _autoCache.shift();
      if(oldest && oldest.t != null) await auto_deleteByT(oldest.t);
    }

    _autoIndex = _autoCache.length - 1;
    refreshAutoNav();
  } catch (e) {
    console.warn('autosave failed', e);
  }
}

async function renderAutosaveAt(i){
  if(!_autoCacheLoaded) await auto_loadCache();
  const arr = auto_list();
  const snap = arr[i];
  if (!snap) return;

  const simRunning = simWorkers.length > 0;

  if (simRunning) {
    _viewingHistoryIndex = i;

    const prevRangeMode = RANGE_MODE;
    const prevRangeToggle = rangeModeToggle ? rangeModeToggle.checked : null;
    const prevBodyRange = document.body.classList.contains('range-mode-on');
    const prevBuckets = (typeof serializeSeatBuckets === 'function')
      ? serializeSeatBuckets()
      : null;

    try {
      if (typeof snap.rangeMode === 'boolean') {
        RANGE_MODE = snap.rangeMode;
        if (rangeModeToggle) rangeModeToggle.checked = RANGE_MODE;
        document.body.classList.toggle('range-mode-on', RANGE_MODE);
      }

      if (Array.isArray(snap.seatBuckets) && typeof applySeatBuckets === 'function') {
        applySeatBuckets(snap.seatBuckets);
      }

      const prevResultsSingle =
        (typeof RESULTS_SINGLE_BOARD !== 'undefined') ? RESULTS_SINGLE_BOARD : false;

      if (typeof RESULTS_SINGLE_BOARD === 'undefined') {
        window.RESULTS_SINGLE_BOARD = !!snap.singleBoardMode;
      } else {
        RESULTS_SINGLE_BOARD = !!snap.singleBoardMode;
      }

      _handsOverrideForRender = Array.isArray(snap.seats) ? snap.seats.slice() : null;
      updateResults(snap.labels, snap.stats, snap.A, snap.B);

      // Restore previous semantics after previewing this snapshot
      RESULTS_SINGLE_BOARD = prevResultsSingle;
    } finally {
      _handsOverrideForRender = null;

      if (typeof applySeatBuckets === 'function') {
        applySeatBuckets(prevBuckets || null);
      }
      RANGE_MODE = prevRangeMode;
      if (rangeModeToggle && prevRangeToggle !== null) {
        rangeModeToggle.checked = prevRangeToggle;
      }
      document.body.classList.toggle('range-mode-on', prevBodyRange);
    }

  } else {
    _viewingHistoryIndex = null;

    let targetMode = snap.mode;
    if (typeof targetMode !== 'number') {
      const rx = /([2-9TJQKA])[SHDCshdc]/g;
      let guess = 4;
      const m = (snap.seats||[]).join(' ').match(rx)||[];
      if (m.length >= 6) guess = 6;
      else if (m.length === 5) guess = 5;
      targetMode = guess;
    }
    if (typeof targetMode === 'number' && targetMode !== CARDS_PER_HAND) {
      setCardMode(targetMode);
    }

    let targetPlayers = (typeof snap.players === 'number') ? snap.players : CURRENT_PLAYERS;
    if (typeof targetPlayers === 'number') {
      CURRENT_PLAYERS = targetPlayers;
      if (typeof clampPlayersForMode === 'function') clampPlayersForMode();
      if (typeof updateNumPlayersUI === 'function') updateNumPlayersUI();
    }

    for (let si = 0; si < seatInputs.length; si++) {
      if (seatInputs[si]) {
        seatInputs[si].value =
          (snap.seats && snap.seats[si]) ? snap.seats[si] : '';
      }
    }

    for (let bi = 0; bi < 5; bi++) {
      const aEl = document.querySelector(`input[data-slot="A${bi}"]`);
      const bEl = document.querySelector(`input[data-slot="B${bi}"]`);
      if (aEl) aEl.value = (snap.A && snap.A[bi]) ? snap.A[bi] : '';
      if (bEl) bEl.value = (snap.B && snap.B[bi]) ? snap.B[bi] : '';
    }

        if (typeof snap.singleBoardMode === 'boolean') {
      SINGLE_BOARD_MODE = snap.singleBoardMode;
      const sbToggle = document.getElementById('singleBoardToggle');
      if (sbToggle) sbToggle.checked = SINGLE_BOARD_MODE;

      if (typeof RESULTS_SINGLE_BOARD === 'undefined') {
        window.RESULTS_SINGLE_BOARD = !!snap.singleBoardMode;
      } else {
        RESULTS_SINGLE_BOARD = !!snap.singleBoardMode;
      }
    }

if (typeof snap.rangeMode === 'boolean') {
      RANGE_MODE = snap.rangeMode;
      if (rangeModeToggle) rangeModeToggle.checked = RANGE_MODE;
      document.body.classList.toggle('range-mode-on', RANGE_MODE);
    }
    if (Array.isArray(snap.seatBuckets) && typeof applySeatBuckets === 'function') {
      applySeatBuckets(snap.seatBuckets);
    } else if (typeof applySeatBuckets === 'function') {
      applySeatBuckets(null);
    }

    // Restore view mode (V Random / V Exact) if we captured it
    if (typeof snap.viewModeExact === 'boolean' && typeof setOmniscientMode === 'function') {
      setOmniscientMode(!!snap.viewModeExact);
    }

    if (typeof enforceSeatLimit === 'function') enforceSeatLimit();
    if (typeof updateSeatPlaceholders === 'function') updateSeatPlaceholders();

    seatInputs.forEach(inp => inp && inp.dispatchEvent(new Event('input', { bubbles:true })));
    boardSlots.forEach(inp => inp && inp.dispatchEvent(new Event('input', { bubbles:true })));

    if (typeof highlightDuplicates === 'function') highlightDuplicates();

    updateResults(snap.labels, snap.stats, snap.A, snap.B);
  }

  _autoIndex = i;
  refreshAutoNav();
}


function refreshAutoNav(){
  const arr = auto_list();
  const prevBtn  = document.getElementById('autoPrev');
  const nextBtn  = document.getElementById('autoNext');
  const liveBtn  = document.getElementById('autoLive');
  const status   = document.getElementById('autoStatus');
  const wrap     = document.getElementById('autoNav');
  const starBtn  = document.getElementById('autoStar');
  const favSel   = document.getElementById('autoFavorites');
  if (!wrap) return;

  const n   = arr.length;
  const has = n > 0;
  const simRunning = simWorkers.length > 0;

  wrap.style.display = has ? 'flex' : 'none';

  const currentSnap = (has && _autoIndex >= 0 && _autoIndex < n)
    ? arr[_autoIndex]
    : null;

  // We consider "live" view to mean: a sim is currently running AND
  // we are not looking at a specific history index. In that case,
  // we should not allow starring the in-flight sim.
  const viewingLive = !!simRunning && _viewingHistoryIndex === null;

  if (status) {
    status.textContent = has ? String((_autoIndex + 1)) + '/' + String(n) : '0/0';
  }

  if (prevBtn) prevBtn.disabled = (!has || _autoIndex <= 0);
  if (nextBtn) nextBtn.disabled = (!has || _autoIndex >= n-1);
  if (liveBtn) liveBtn.style.display = simRunning ? 'inline-flex' : 'none';

  // Update star button state
  if (starBtn) {
    // When viewing the *live* in-flight sim, disable starring so we don't
    // mark a scenario that's still changing. When browsing autosaved
    // history, starring remains allowed even while a sim is running.
    if (!currentSnap || viewingLive) {
      starBtn.disabled = true;
      starBtn.textContent = 'â˜† Star';
      starBtn.classList.remove('primary');
    } else {
      const isFav = !!currentSnap.favorite;
      starBtn.disabled = false;
      starBtn.textContent = isFav ? 'â˜… Starred' : 'â˜† Star';
      starBtn.classList.toggle('primary', isFav);
    }
  }

  // Rebuild favorites dropdown
  if (favSel) {
    const previousValue = favSel.value;
    while (favSel.firstChild) favSel.removeChild(favSel.firstChild);

    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'â˜… Favorites';
    placeholder.disabled = true;
    favSel.appendChild(placeholder);

    const favorites = arr
      .map((snap, idx) => ({ snap, idx }))
      .filter(pair => pair.snap && pair.snap.favorite);

    favorites.forEach(({ snap, idx }) => {
      const opt = document.createElement('option');
      opt.value = String(idx);

      // Helper: format a raw seat string into spaced + sorted card tokens, e.g.
      // "3CQH7x7H3Hxx" â†’ "Qh 7h 7x 3h 3c Xx" (Aâ€“2 by rank, wilds last).
      function formatSeatLabel(raw) {
        if (!raw) return '';
        // Keep only rank/suit/wild chars, normalize to uppercase.
        const cleaned = String(raw).toUpperCase().replace(/[^2-9TJQKAXSHDC]/g, '');

        const exact = [];      // concrete cards: e.g. "QH", "3C"
        const rankWilds = [];  // rank-specific wilds: e.g. "7X" â†’ "7x"
        const suitWilds = [];  // suit-specific wilds: e.g. "XS" â†’ "Xs"
        let fullWildCount = 0; // fully unknown "XX" slots

        for (let i = 0; i + 1 < cleaned.length; i += 2) {
          const r = cleaned[i];
          const s = cleaned[i + 1];
          if (!r || !s) break;

          if ((r in RANK_VAL) && SUITS.includes(s)) {
            // Exact known card
            exact.push(r + s);
          } else if ((r in RANK_VAL) && s === 'X') {
            // Rankâ€‘only wildcard (7x etc.)
            rankWilds.push(r + 'X');
          } else if (r === 'X' && SUITS.includes(s)) {
            // Suitâ€‘only wildcard (Xs etc.)
            suitWilds.push('X' + s);
          } else {
            // Anything else, count as fully wild "Xx"
            fullWildCount++;
          }
        }

        if (!exact.length && !rankWilds.length && !suitWilds.length && !fullWildCount) {
          return '';
        }

        function rankValFromToken(t) {
          const r = t[0];
          return (r in RANK_VAL) ? RANK_VAL[r] : -1;
        }

        const items = [];
        exact.forEach(c => items.push({ token: c, type: 'exact' }));
        rankWilds.forEach(c => items.push({ token: c, type: 'rankWild' }));
        suitWilds.forEach(c => items.push({ token: c, type: 'suitWild' }));

        // Sort by rank (A high to 2 low), then by type so exact > suitWild > rankWild.
        const typeOrder = { exact: 0, suitWild: 1, rankWild: 2 };
        items.sort((a, b) => {
          const va = rankValFromToken(a.token);
          const vb = rankValFromToken(b.token);
          if (va !== vb) return vb - va;
          return (typeOrder[a.type] - typeOrder[b.type]);
        });

        const tokens = items.map(item => {
          const t = item.token;
          const r = t[0];
          const s = t[1];
          if (item.type === 'exact')   return r + s.toLowerCase(); // "Qh"
          if (item.type === 'rankWild') return r + 'x';            // "7x"
          if (item.type === 'suitWild') return 'X' + s.toLowerCase(); // "Xs"
          return 'Xx';
        });

        // Fully unknown Xx slots always come last.
        for (let i = 0; i < fullWildCount; i++) {
          tokens.push('Xx');
        }

        return tokens.join(' ');
      }

      // Build a short label: players + mode + first non-empty seat
      const players = (typeof snap.players === 'number') ? snap.players : '?';
      const mode    = (typeof snap.mode === 'number') ? snap.mode : '?';
      let seatSample = '';
      if (Array.isArray(snap.seats)) {
        const rawSeat = snap.seats.find(s => s && s.trim()) || '';
        seatSample = formatSeatLabel(rawSeat);
        if (seatSample.length > 24) {
          seatSample = seatSample.slice(0, 24) + 'â€¦';
        }
      }
      const labelParts = [`P${players}`, `${mode}c`];
      if (seatSample) labelParts.push(seatSample);
      opt.textContent = 'â˜… ' + labelParts.join(' Â· ');

      if (idx === _autoIndex) {
        opt.selected = true;
      }

      favSel.appendChild(opt);
    });

    // Enable/disable based on whether we have any favorites
    favSel.disabled = favorites.length === 0;

    // If nothing is selected and we have favorites, keep placeholder selected
    if (!favSel.value && favorites.length > 0) {
      favSel.selectedIndex = 0;
    }
  }
}

// Add autosave nav controls to Results panel once.
document.addEventListener('DOMContentLoaded', async ()=>{
  const host = document.getElementById('resultsFilters') || document.querySelector('.panel.results');

  // Build minimal nav UI if not already present
  if(host && !document.getElementById('autoNav')){
    const div = document.createElement('div');
    div.id = 'autoNav';
    div.className = 'controls-extended';
    div.style.marginTop = '6px';
    div.innerHTML = `
      <span class="badge" id="autoStatus">0/0</span>
      <button class="btn ghost" id="autoPrev" title="Previous autosaved scenario">â—€ï¸ Prev</button>
      <button class="btn ghost" id="autoNext" title="Next autosaved scenario">Next â–¶ï¸</button>
      <button class="btn" id="autoLive" title="Back to live/current sim">Live âŸ³</button>
      <button class="btn ghost" id="autoClear" title="Clear autosaved scenarios">ğŸ—‘ï¸ Clear</button>
      <button class="btn ghost" id="autoStar" title="Star / unstar this autosave">â˜† Star</button>
      <select id="autoFavorites" class="favorites-select" title="Jump to a starred scenario">
        <option value="" disabled selected>â˜… Favorites</option>
      </select>
    `;
    host.appendChild(div);
  }

  const prev = async () => {
    const i = Math.max(0, _autoIndex - 1);
    await renderAutosaveAt(i);
  };
  const next = async () => {
    const i = Math.min(auto_list().length - 1, _autoIndex + 1);
    await renderAutosaveAt(i);
  };
  const live = () => {
    _viewingHistoryIndex = null;
    _handsOverrideForRender = null;
    try {
      if (typeof _lastLabels !== 'undefined' &&
          _lastLabels &&
          typeof updateResults === 'function') {
        updateResults(_lastLabels, _lastStats, _lastBoardA, _lastBoardB);
      }
    } catch (e) {
      console.warn('Live view refresh failed, will update on next worker tick.', e);
    }
    refreshAutoNav();
  };

  document.getElementById('autoPrev')?.addEventListener('click', prev);
  document.getElementById('autoNext')?.addEventListener('click', next);
  document.getElementById('autoLive')?.addEventListener('click', live);

  const clear = async () => {
    if (!confirm('Are you sure you want to clear all autosaved scenarios? This cannot be undone.')) return;
    await auto_clearAll();
    _autoCache = [];
    _autoIndex = -1;
    refreshAutoNav();
    alert('History cleared.');
  };
  document.getElementById('autoClear')?.addEventListener('click', clear);

  // Toggle favorite for the current autosave
  const starHandler = async () => {
    const arr = auto_list();
    if (!_autoCacheLoaded || !arr.length || _autoIndex < 0 || _autoIndex >= arr.length) return;
    const snap = arr[_autoIndex];
    snap.favorite = !snap.favorite;
    try {
      await auto_addSnap(snap); // overwrite in IndexedDB
      refreshAutoNav();
    } catch (e) {
      console.warn('Failed to toggle favorite flag', e);
    }
  };
  const starBtn = document.getElementById('autoStar');
  if (starBtn) {
    starBtn.addEventListener('click', starHandler);
  }

  // Jump to a selected favorite
  const favSel = document.getElementById('autoFavorites');
  if (favSel) {
    favSel.addEventListener('change', async (ev) => {
      const value = ev.target.value;
      if (!value) return;
      const idx = parseInt(value, 10);
      if (!Number.isNaN(idx)) {
        await renderAutosaveAt(idx);
      }
    });
  }

  await auto_loadCache();
  _autoIndex = _autoCache.length ? _autoCache.length - 1 : -1;
  refreshAutoNav();
});

  // --- Bucket example generator & tuner UI (main thread) ---

  function analyzeHandForBucketLocal(hand){
    const n = hand.length;
    const ranks = hand.map(c => RANK_VAL[c[0]]).sort((a,b) => b - a); // high to low

    // Suit counts
    const suits = hand.map(c => c[1]);
    const suitCounts = {};
    for (const s of suits) {
      suitCounts[s] = (suitCounts[s] || 0) + 1;
    }
    let maxSuitCount = 0;
    Object.values(suitCounts).forEach(c => { if (c > maxSuitCount) maxSuitCount = c; });
    const twoPlusSuitCount = Object.values(suitCounts).filter(c => c >= 2).length;
    const doubleSuited = twoPlusSuitCount >= 2;
    const singleSuited = twoPlusSuitCount === 1;

    // Rank counts
    const rankCounts = {};
    for (const r of ranks) {
      rankCounts[r] = (rankCounts[r] || 0) + 1;
    }
    let pairs = 0, trips = 0, quads = 0, highestPairRank = -1;
    for (const [rkStr, cnt] of Object.entries(rankCounts)) {
      const rk = parseInt(rkStr, 10);
      if (cnt === 2) {
        pairs++;
        if (rk > highestPairRank) highestPairRank = rk;
      } else if (cnt === 3) {
        trips++;
      } else if (cnt === 4) {
        quads++;
      }
    }

    const hasAce = ranks.includes(RANK_VAL['A']);
    const broadway = ranks.filter(r => r >= RANK_VAL['T']).length;

    // Simple connectivity metrics: compress ranks and count gaps
    const uniq = [...new Set(ranks)].sort((a,b) => b - a);
    let gapSum = 0;
    for (let i = 0; i < uniq.length - 1; i++) {
      gapSum += Math.max(0, uniq[i] - uniq[i+1] - 1);
    }
    let bestRun = 1, cur = 1;
    for (let i = 0; i < uniq.length - 1; i++) {
      if (uniq[i] - uniq[i+1] <= 1) cur++;
      else cur = 1;
      if (cur > bestRun) bestRun = cur;
    }

    return {
      n,
      ranks,
      maxSuitCount,
      pairs,
      trips,
      quads,
      highestPairRank,
      hasAce,
      broadway,
      gapSum,
      connectedRun: bestRun,
      doubleSuited,
      singleSuited
    };
  }

  function classifyBucketFromFeaturesLocal(info){
    const high    = info.ranks[0];
    const isDS    = !!info.doubleSuited;
    const isSS    = !!info.singleSuited;
    const hasAce  = !!info.hasAce;

    const strongPair = info.pairs >= 1 && info.highestPairRank >= RANK_VAL['T']; // TT+
    const anyPair    = info.pairs >= 1 || info.trips >= 1 || info.quads >= 1;

    const dsScore   = isDS ? 2.0 * BUCKET_CFG.dsWeight : 0;
    const ssScore   = isSS ? 1.0 * BUCKET_CFG.dsWeight : 0;
    const bwScore   = info.broadway * BUCKET_CFG.broadwayWeight;
    const gapAdj    = info.gapSum / 2;
    const connScore = info.connectedRun - BUCKET_CFG.gapPenalty * gapAdj;
    const pairScore = strongPair ? 2.0 : (anyPair ? 1.0 : 0.0);
    const aceScore  = hasAce ? 0.75 : 0.0;
    const highScore = (high / 12) * 1.0;

    const raw = dsScore + ssScore + bwScore + connScore + pairScore + aceScore + highScore;

    if (raw >= 7.5) return 1;
    if (raw >= 5.5) return 2;
    if (raw >= 3.75) return 3;
    if (raw >= 2.0) return 4;
    return 5;
  }

  function classifyBucketLocal(hand){
    const info = analyzeHandForBucketLocal(hand);
    return classifyBucketFromFeaturesLocal(info);
  }

  function randomHandForBucketLocal(bucket, handSize){
    const MAX_ATTEMPTS = 400;
    for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
      const deck = fullDeck();
      const cand = takeN(deck, handSize);
      if (classifyBucketLocal(cand) === bucket) return cand;
    }
    return null;
  }

  function generateBucketExamplesText(){
    const handSize = CARDS_PER_HAND || 4;
    const lines = [];
    for (let b = 1; b <= 5; b++) {
      const h = randomHandForBucketLocal(b, handSize);
      if (h && h.length === handSize) {
        lines.push(`Bucket ${b}: ${h.join(' ')}`);
      } else {
        lines.push(`Bucket ${b}: (no example found in sampler)`);
      }
    }
    return lines.join('\n');
  }


// ---- Merged from earlier script ----
// ----- Pot odds / MDF / SPR helper (player-aware, multiway MDF) -----
(function() {
  const potInput   = document.getElementById('poPot');
  const betInput   = document.getElementById('poBet');
  const stackInput = document.getElementById('poStack');
  const output     = document.getElementById('poOutput');
  const clearBtn   = document.getElementById('poClear');

  if (!potInput || !betInput || !stackInput || !output || !clearBtn) {
    return; // fails gracefully if panel is missing
  }

  // Count active seats:
  // - Exact hands: non-empty input
  // - Ranges: â‰¥1 active bucket for that seat (using your existing range wiring)
  function countActiveSeats() {
    if (typeof seatInputs === 'undefined' || !Array.isArray(seatInputs)) {
      return NaN;
    }
    let n = 0;
    seatInputs.forEach((inp, idx) => {
      if (!inp) return;
      const txt = (inp.value || '').trim();
      const hasExact = !!txt;

      let hasRange = false;
      if (typeof RANGE_MODE !== 'undefined' && RANGE_MODE &&
          typeof getBucketsForSeat === 'function') {
        const buckets = getBucketsForSeat(idx) || [];
        if (buckets.length > 0) hasRange = true;
      }

      if (hasExact || hasRange) {
        n++;
      }
    });
    return n;
  }

  function fmtPct(x) {
    if (!isFinite(x)) return 'â€“';
    return (x * 100).toFixed(1) + '%';
  }

  function classifySPR(spr, players) {
    if (!isFinite(spr) || spr <= 0) return 'n/a';

    const multiway = players >= 3;
    if (spr <= 1.5) {
      return multiway
        ? 'very low multiway â€“ you can still stack off wide with strong made hands / nutty combo draws'
        : 'very low â€“ fine to stack off wide with strong made hands and big combo draws';
    } else if (spr <= 3) {
      return multiway
        ? 'low multiway â€“ be a bit tighter; strong made hands + nutty draws stack off'
        : 'low â€“ comfortable stacking off strong overpairs/top 2 + nutty draws';
    } else if (spr <= 6) {
      return multiway
        ? 'medium multiway â€“ prefer nuttier made hands or very strong draws to stack off'
        : 'medium â€“ stack off more selectively with strong made hands / very strong draws';
    } else {
      return multiway
        ? 'high multiway â€“ avoid stacking off with one-pair / marginal draws; chase nutty stuff'
        : 'high â€“ avoid stacking off with one-pair / marginal draws';
    }
  }

  function recalc() {
    const P = parseFloat(potInput.value);
    const B = parseFloat(betInput.value);
    const S = parseFloat(stackInput.value);
    const players = countActiveSeats();

    if (!isFinite(P) || P <= 0 || !isFinite(B) || B <= 0) {
      const base = 'Enter pot + bet to see pot odds & MDF.';
      if (!isFinite(players) || players <= 0) {
        output.textContent = base + ' (No active seats yet.)';
      } else {
        output.textContent = base + ` Players in hand: ${players}.`;
      }
      return;
    }

    // Facing a bet B into pot P:
    // Call amount = B
    // Final pot if we call = P + 2B
    // Required equity to call = B / (P + 2B)
    const call = B;
    const potAfterCall = P + B + call;
    const reqEqCall = call / potAfterCall;

    // MDF vs bet B into pot P:
    // MDF = 1 - B / (P + B) = P / (P + B)
    const mdf = P / (P + B);

    const lines = [];

    if (isFinite(players) && players > 0) {
      lines.push(`Players in hand: ${players}.`);
      if (players >= 2) {
        const equalShareEq = 1 / players;
        lines.push(
          `If equities were evenly split ${players}-way, each player has â‰ˆ ${fmtPct(equalShareEq)} equity.`
        );
      }
    } else {
      lines.push('Players in hand: n/a (no active seats detected).');
    }

    // MDF messaging:
    if (players >= 3) {
      // Multiway: MDF belongs to the whole field, then gets split
      const perPlayerMdf = mdf / players; // simple equal-share approximation
      lines.push(
        `Table MDF vs this bet: the field should continue â‰ˆ ${fmtPct(mdf)} of hands in total.`
      );
      lines.push(
        `Evenly split among ${players} players, thatâ€™s â‰ˆ ${fmtPct(perPlayerMdf)} of each playerâ€™s range.`
      );
    } else {
      // Heads-up-ish case (2 players): classic single-opponent MDF
      lines.push(
        `MDF vs this bet (HU approx): defend â‰ˆ ${fmtPct(mdf)} of your range.`
      );
    }

    if (isFinite(S) && S > 0 && P > 0) {
      const spr = S / P;
      const reqEqAllIn = S / (P + 2 * S);

      lines.push(`SPR â‰ˆ ${spr.toFixed(1)} (${classifySPR(spr, players)}).`);
      lines.push(`If stacks go in now, call needs â‰ˆ ${fmtPct(reqEqAllIn)} equity.`);
    }

    output.innerHTML = lines.join('<br>');
  }

  function clearAll() {
    potInput.value   = '';
    betInput.value   = '';
    stackInput.value = '';
    output.textContent = 'Enter pot + bet to see pot odds & MDF.';
  }

  potInput.addEventListener('input', recalc);
  betInput.addEventListener('input', recalc);
  stackInput.addEventListener('input', recalc);
  clearBtn.addEventListener('click', clearAll);

  // Refresh when seats / ranges change so player count is live
  if (typeof seatInputs !== 'undefined' && Array.isArray(seatInputs)) {
    seatInputs.forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', recalc);
    });
  }

  // Bucket range toggles
  document.addEventListener('click', (e) => {
    const t = e.target;
    if (!t || !t.classList) return;
    if (t.classList.contains('bucketBtn')) {
      setTimeout(recalc, 0);
    }
  });

  // Initial message
  clearAll();
})();


// ---- Merged from earlier script ----
(function(){
  'use strict';
  // FINAL override: strict per-seat parse with no duplicate concrete cards.
  window.parseHand = function(str){
    if (!str) return [];
    var t = String(str).toUpperCase().trim();
    if (!t) return [];
    // Normalize separators
    t = t.replace(/[,/|;-]+/g, ' ');
    var parts;
    if (t.indexOf(' ') !== -1) {
      parts = t.split(/\s+/);
    } else {
      // Compact input like "XS2S2S3S3S" -> ["XS","2S","2S","3S","3S"]
      parts = [];
      for (var i = 0; i + 1 < t.length; i += 2) {
        parts.push(t.slice(i, i + 2));
      }
    }
    var out = [];
    if (parts && parts.length) {
      for (var j = 0; j < parts.length; j++) {
        var c = normalizeCard(parts[j]);
        if (c) out.push(c);
      }
    }
    // Deduplicate concrete cards within this seat
    var seen = Object.create(null);
    var uniq = [];
    for (var k = 0; k < out.length; k++) {
      var card = out[k];
      if (!seen[card]) {
        seen[card] = true;
        uniq.push(card);
      }
    }
    if (typeof CARDS_PER_HAND === 'number' && CARDS_PER_HAND > 0) {
      return uniq.slice(0, CARDS_PER_HAND);
    }
    return uniq;
  };
})();



// Force default startup mode = V Exact (Omniscient)
document.addEventListener('DOMContentLoaded', () => {
  const vm = document.getElementById('viewModeSelect');
  if (vm && vm.value !== 'exact') vm.value = 'exact';
});
</script>
</body>
</html>



